<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6. Synchronisation - Lernportal Betriebssysteme</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Zilla+Slab:wght@700&display=swap" rel="stylesheet">
    <style>
        .page-nav { background-color: #f8f9fa; padding: 10px 0; border-bottom: 1px solid var(--border-color); font-family: var(--header-font); }
        .page-nav a { color: var(--primary-color); text-decoration: none; font-weight: bold; }
        .page-nav a:hover { text-decoration: underline; }
        .content-section h3 { font-family: var(--title-font); font-size: 1.8rem; color: #444; margin-top: 40px; margin-bottom: 20px; }
        .content-section h4 { font-family: var(--title-font); font-size: 1.4rem; color: var(--primary-color); margin-top: 30px; }
        blockquote { border-left: 4px solid var(--primary-color); padding-left: 20px; margin: 20px 0; font-style: italic; background-color: var(--secondary-color); padding: 15px 20px; border-radius: 0 5px 5px 0; }
        .image-placeholder { background-color: #f0f0f0; border: 1px dashed #ccc; padding: 20px; text-align: center; margin: 20px auto; border-radius: 5px; color: #888; max-width: 80%; display: block; font-family: var(--header-font); }
        code, pre { font-family: Consolas, 'Courier New', monospace; background-color: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; }
        code { padding: 2px 5px; }
        pre { padding: 15px; overflow-x: auto; white-space: pre-wrap; font-size: 0.9em; }
        .key-term { font-weight: bold; color: var(--primary-color); }
        table { width: 100%; margin-top: 20px; border-collapse: collapse; }
        th, td { border: 1px solid var(--border-color); padding: 12px; text-align: left; }
        th { background-color: var(--secondary-color); font-family: var(--header-font); }
        .problem-box { border: 2px solid #c7254e; padding: 20px; border-radius: 5px; background-color: #f9e2e8; margin-top: 20px; }
        .solution-box { border: 2px solid #28a745; padding: 20px; border-radius: 5px; background-color: #eaf6ec; margin-top: 20px; }
    </style>
</head>
<body>

    <nav class="site-nav">
        <div class="container">
        <button class="nav-toggle" aria-label="Men√º umschalten">&#9776;</button>
        <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Dark Mode umschalten">üåô</button>
            <a href="index.html">Zur√ºck zur √úbersicht</a>
            <a href="01_einfuehrung.html">1</a>
            <a href="02_grundlagen.html">2</a>
            <a href="03_prozesse.html">3</a>
            <a href="04_threads.html">4</a>
            <a href="05_scheduling.html">5</a>
            <a href="06_synchronisation.html" class="active">6</a>
            <a href="07_kommunikation.html">7</a>
            <a href="08_deadlocks.html">8</a>
            <a href="09_speicherverwaltung.html">9</a>
            <a href="10_dateisysteme.html">10</a>
        </div>
    </nav>
    <header>
        <div class="container">
            <h1>Kapitel 6: Synchronisation</h1>
            <p>Die Beherrschung des kontrollierten Chaos von nebenl√§ufigen Prozessen und Threads.</p>
        </div>
    </header>
    <main class="container">
        <article class="content-section">
            <h2>Das Problem der Nebenl√§ufigkeit</h2>
            <p>Betriebssysteme erm√∂glichen die <span class="key-term">nebenl√§ufige</span> Ausf√ºhrung von Prozessen und Threads. Dies f√ºhrt zu einem <span class="key-term">Indeterminismus</span>: Die relative Ausf√ºhrungsreihenfolge ist nicht vorhersagbar.</p>
            <p>Problematisch, wenn:</p>
            <ul>
                <li>Gemeinsame Betriebsmittel (z.B. Drucker) genutzt werden.</li>
                <li>Gemeinsame Daten (z.B. globale Variablen) bearbeitet werden.</li>
                <li>Prozesse kooperieren m√ºssen.</li>
            </ul>
            <div class="problem-box">
                <h4>Wettlaufsituation (Race Condition)</h4>
                <p>Wenn mehrere Threads oder Prozesse auf dieselben gemeinsam genutzten Daten zugreifen und das Endergebnis von der nicht vorhersagbaren Reihenfolge der Zugriffe abh√§ngt, spricht man von einer Race Condition. Dies kann zu inkonsistenten Datenzust√§nden f√ºhren.</p>
                <div class="image-placeholder">[Diagramm: Homebanking-Transaktionen mit falschem Kontostand]</div>
            </div>
            <h3>Kritischer Abschnitt und Wechselseitiger Ausschluss</h3>
            <p>Der Teil des Programmcodes, der auf gemeinsame Ressourcen zugreift, wird als <span class="key-term">kritischer Abschnitt (Critical Section)</span> bezeichnet. Um Race Conditions zu vermeiden, muss sichergestellt werden, dass sich zu jedem Zeitpunkt nur ein einziger Thread oder Prozess in seinem kritischen Abschnitt befinden kann. Dieses Prinzip nennt man <span class="key-term">wechselseitiger Ausschluss (Mutual Exclusion)</span>.</p>
            <h2>L√∂sungsans√§tze</h2>
            <h4>1. Interrupts sperren</h4>
            <p>Die einfachste Methode auf einem Einprozessorsystem ist das Sperren aller Interrupts vor dem Betreten eines kritischen Abschnitts. Dies verhindert Kontextwechsel und damit den Zugriff durch andere Prozesse. Nachteile sind die Blockade wichtiger E/A-Operationen und die Unwirksamkeit auf Mehrprozessorsystemen.</p>
            <h4>2. Software mit Busy Waiting</h4>
            <p>Hierbei wartet ein Prozess in einer aktiven Schleife (Busy Waiting), bis er den kritischen Abschnitt betreten darf. Dies verschwendet CPU-Zyklen. Beispiele sind eine einfache Lock-Variable (die jedoch selbst anf√§llig f√ºr Race Conditions ist) oder der komplexere, aber korrekte Peterson-Algorithmus.</p>
            <h4>3. Hardware-Unterst√ºtzung</h4>
            <p>Moderne Prozessoren bieten atomare Befehle wie <code>test_and_set()</code>, die eine Variable in einem unteilbaren Schritt lesen, testen und setzen. Damit lassen sich robuste Locking-Mechanismen implementieren, die allerdings immer noch auf Busy Waiting basieren.</p>
            <h2>Semaphore</h2>
            <p>Ein von Dijkstra 1965 eingef√ºhrtes Synchronisationsinstrument. Ein Semaphor ist im Wesentlichen eine Z√§hlvariable, auf die nur √ºber zwei atomare Operationen zugegriffen werden kann: <code>wait()</code> (auch P genannt, von `proberen` - testen) und <code>signal()</code> (auch V genannt, von `verhogen` - erh√∂hen). Anstatt CPU-Zeit durch aktives Warten zu verschwenden, werden Prozesse, die auf einen Semaphor warten m√ºssen, vom Scheduler blockiert und in eine Warteschlange eingereiht.</p>
            <p><strong>Bin√§rer Semaphor (Mutex):</strong> Kann nur die Werte 0 oder 1 annehmen und wird zur Realisierung des wechselseitigen Ausschlusses (Mutex) verwendet. Eine Initialisierung mit 1 bedeutet "frei", 0 bedeutet "besetzt".</p>
            <div class="solution-box">
                <h4>Beispiel Java-Semaphor</h4>
                <pre>
import java.util.concurrent.Semaphore;

// Initialisierung als Mutex (fair: FIFO-Warteschlange)
static Semaphore mutex = new Semaphore(1, true);

try {
    mutex.acquire(); // Entspricht Wait(S): Eintritt in krit. Abschnitt
    // ... kritischer Abschnitt ...
} catch (InterruptedException e) {
    // ...
} finally {
    mutex.release(); // Entspricht Signal(S): Austritt
}
                </pre>
            </div>
            <h2>Monitore</h2>
            <p>Ein Monitor ist ein h√∂heres, objektorientiertes Synchronisationskonzept. Er kapselt Daten zusammen mit den Methoden, die darauf operieren. Der entscheidende Punkt ist, dass der Compiler automatisch daf√ºr sorgt, dass sich zu jedem Zeitpunkt nur ein Thread innerhalb einer der Monitormethoden aufhalten kann. Die Methoden sind also implizit durch einen Mutex gesch√ºtzt.</p>
            <h4>Bedingungsvariablen</h4>
            <p>Um innerhalb eines Monitors eine Kooperation zu erm√∂glichen (z.B. ein Verbraucher muss warten, bis ein Erzeuger Daten bereitgestellt hat), gibt es Bedingungsvariablen. Diese bieten typischerweise zwei Operationen:
            <ul>
                <li><code>wait()</code>: Der aufrufende Thread gibt die Monitorsperre frei und blockiert, bis er von einem anderen Thread geweckt wird.</li>
                <li><code>notify() / notifyAll()</code>: Weckt einen (notify) oder alle (notifyAll) Threads, die auf derselben Bedingungsvariable warten.</li>
            </ul></p>
            <div class="solution-box">
                <h4>Beispiel Java-Monitor</h4>
                <p>In Java kann jede Klasse als Monitor fungieren. Das Schl√ºsselwort <code>synchronized</code> vor einer Methode macht diese zu einer Monitormethode. Die Methoden <code>wait()</code>, <code>notify()</code> und <code>notifyAll()</code> sind in der `Object`-Klasse definiert.</p>
                <pre>
// 'synchronized' macht die Methode zu einem kritischen Abschnitt
public synchronized void transfer(int amount) throws InterruptedException {
    // Warten, solange der Puffer leer ist
    while (buffer.isEmpty()) {
        wait(); // Gibt die Sperre ab und blockiert
    }
    // ... Verarbeitung ...
    // Einen wartenden Thread aufwecken
    notifyAll();
}
                </pre>
            </div>
            <h2>Klassische Probleme</h2>
            <h4>Erzeuger-Verbraucher (Producer-Consumer)</h4>
            <p>Ein oder mehrere Erzeuger-Threads produzieren Daten und legen sie in einem begrenzten Puffer ab. Ein oder mehrere Verbraucher-Threads entnehmen die Daten aus dem Puffer. Die Synchronisation muss sicherstellen, dass Erzeuger nicht in einen vollen und Verbraucher nicht aus einem leeren Puffer zugreifen, und dass der Zugriff auf den Puffer selbst wechselseitig ausgeschlossen ist.</p>
            <h4>Leser-Schreiber</h4>
            <p>Mehrere Threads greifen auf eine gemeinsame Datenstruktur zu. Dabei d√ºrfen beliebig viele Leser gleichzeitig zugreifen. Sobald aber ein Schreiber zugreifen will, muss er exklusiven Zugriff erhalten; keine anderen Leser oder Schreiber d√ºrfen aktiv sein.</p>
            <h4>Barriere / Rendezvous</h4>
            <p>Eine Gruppe von N Threads muss an einem bestimmten Punkt im Code (der Barriere) aufeinander warten. Keiner der Threads darf fortfahren, bevor nicht alle N Threads die Barriere erreicht haben. Dies kann mit einem Z√§hler, einem Mutex-Semaphor zum Schutz des Z√§hlers und einem zweiten Semaphor als eigentliche Barriere implementiert werden.</p>
            <h2>Generelle Semaphore</h2>
            <p>Ein Semaphor, dessen Z√§hler beliebige ganze Zahlen annehmen kann.
            <ul>
                <li><code>Wait(S):</code> Dekrementiert S. Wenn S danach negativ ist, wird der Prozess blockiert. Die absolute H√∂he des negativen Werts entspricht der Anzahl der wartenden Prozesse.</li>
                <li><code>Signal(S):</code> Inkrementiert S. Wenn S danach nicht positiv ist (d.h. ‚â§ 0), wird ein wartender Prozess deblockiert.</li>
            </ul></p>
            <h2>Synchronisationsdienste in UNIX/Linux</h2>
            <h4>POSIX-Thread-Mutex</h4>
            <pre>
#include <pthread.h>

pthread_mutex_t my_mutex = PTHREAD_MUTEX_INITIALIZER;

pthread_mutex_lock(&my_mutex);
// kritischer Abschnitt
pthread_mutex_unlock(&my_mutex);
            </pre>
            <h4>System-V-Semaphoren</h4>
            <pre>
int semid = semget(key, 1, IPC_CREAT | 0666);
semctl(semid, 0, SETVAL, initialValue);

// Wait
struct sembuf op = {0, -1, 0};
semop(semid, &op, 1);
// Signal
op.sem_op = +1;
semop(semid, &op, 1);
            </pre>
            <h2>Synchronisationsdienste in Windows</h2>
            <h4>Kritische Abschnitte</h4>
            <pre>
CRITICAL_SECTION cs;
InitializeCriticalSection(&cs);
EnterCriticalSection(&cs);
// kritischer Abschnitt
LeaveCriticalSection(&cs);
            </pre>
            <h4>Mutex und Semaphore</h4>
            <pre>
HANDLE hMutex = CreateMutex(NULL, FALSE, NULL);
WaitForSingleObject(hMutex, INFINITE);
ReleaseMutex(hMutex);

HANDLE hSem = CreateSemaphore(NULL, initialCount, maxCount, NULL);
WaitForSingleObject(hSem, INFINITE);
ReleaseSemaphore(hSem, 1, NULL);
            </pre>
        </article>
    </main>
    <footer>
        <div class="container">
            <p>Erstellt zur Unterst√ºtzung der Pr√ºfungsvorbereitung. Viel Erfolg bei der Klausur!</p>
        </div>
    </footer>
    <script src="js/main.js"></script>
</body>
</html>