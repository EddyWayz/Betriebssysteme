<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Kapitel 6 - Synchronisation."/>
    <title>6. Synchronisation - Lernportal Betriebssysteme</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Zilla+Slab:wght@700&display=swap" rel="stylesheet">
</head>
<body>

<nav class="site-nav" role="navigation" aria-label="Hauptnavigation"></nav>
    <header role="banner">
        <div class="container">
            <h1 id="synchronisation">Kapitel 6: Synchronisation</h1>
            <p>Die Beherrschung des kontrollierten Chaos von nebenläufigen Prozessen und Threads.</p>
        </div>
    </header>
    <main class="container" role="main">
        <article class="content-section">
            <h2>Das Problem der Nebenläufigkeit</h2>
            <p>Betriebssysteme ermöglichen die <span class="key-term">nebenläufige</span> Ausführung von <a class="quicklink" href="03_prozesse.html#prozess">Prozessen</a> und <a class="quicklink" href="04_threads.html#threads">Threads</a>. Dies führt zu einem <span class="key-term">Indeterminismus</span>: Die relative Ausführungsreihenfolge ist nicht vorhersagbar.</p>
            <p>Problematisch, wenn:</p>
            <ul>
                <li>Gemeinsame Betriebsmittel (z.B. Drucker) genutzt werden.</li>
                <li>Gemeinsame Daten (z.B. globale Variablen) bearbeitet werden.</li>
                <li>Prozesse kooperieren müssen.</li>
            </ul>
            <div class="problem-box">
                <h4 id="race-condition">Wettlaufsituation (Race Condition)</h4>
                <p>Wenn mehrere Threads oder Prozesse auf dieselben gemeinsam genutzten Daten zugreifen und das Endergebnis von der nicht vorhersagbaren Reihenfolge der Zugriffe abhängt, spricht man von einer Race Condition. Dies kann zu inkonsistenten Datenzuständen führen.</p>
                <img src="images/placeholder.svg" class="illustration" alt="Diagramm: Homebanking-Transaktionen mit falschem Kontostand">
            </div>
            <h3>Kritischer Abschnitt und Wechselseitiger Ausschluss</h3>
            <p>Der Teil des Programmcodes, der auf gemeinsame Ressourcen zugreift, wird als <span id="kritischer-abschnitt" class="key-term">kritischer Abschnitt (Critical Section)</span> bezeichnet. Um Race Conditions zu vermeiden, muss sichergestellt werden, dass sich zu jedem Zeitpunkt nur ein einziger Thread oder Prozess in seinem kritischen Abschnitt befinden kann. Dieses Prinzip nennt man <span class="key-term">wechselseitiger Ausschluss (Mutual Exclusion)</span>.</p>
            <h2>Lösungsansätze</h2>
            <h4>1. <a class="quicklink" href="02_grundlagen.html#interrupts">Interrupts</a> sperren</h4>
            <p>Die einfachste Methode auf einem Einprozessorsystem ist das Sperren aller Interrupts vor dem Betreten eines kritischen Abschnitts. Dies verhindert Kontextwechsel und damit den Zugriff durch andere Prozesse. Nachteile sind die Blockade wichtiger E/A-Operationen und die Unwirksamkeit auf Mehrprozessorsystemen.</p>
            <h4>2. Software mit Busy Waiting</h4>
            <p>Hierbei wartet ein Prozess in einer aktiven Schleife (Busy Waiting), bis er den kritischen Abschnitt betreten darf. Dies verschwendet CPU-Zyklen. Beispiele sind eine einfache Lock-Variable (die jedoch selbst anfällig für Race Conditions ist) oder der komplexere, aber korrekte Peterson-Algorithmus.</p>
            <h4>3. Hardware-Unterstützung</h4>
            <p>Moderne Prozessoren bieten atomare Befehle wie <code>test_and_set()</code>, die eine Variable in einem unteilbaren Schritt lesen, testen und setzen. Damit lassen sich robuste Locking-Mechanismen implementieren, die allerdings immer noch auf Busy Waiting basieren.</p>
            <h2 id="semaphore">Semaphore</h2>
            <p>Ein von Dijkstra 1965 eingeführtes Synchronisationsinstrument. Ein Semaphor ist im Wesentlichen eine Zählvariable, auf die nur über zwei atomare Operationen zugegriffen werden kann: <code>wait()</code> (auch P genannt, von `proberen` - testen) und <code>signal()</code> (auch V genannt, von `verhogen` - erhöhen). Anstatt CPU-Zeit durch aktives Warten zu verschwenden, werden Prozesse, die auf einen Semaphor warten müssen, vom Scheduler blockiert und in eine Warteschlange eingereiht.</p>
            <p><strong>Binärer Semaphor (Mutex):</strong> Kann nur die Werte 0 oder 1 annehmen und wird zur Realisierung des wechselseitigen Ausschlusses (Mutex) verwendet. Eine Initialisierung mit 1 bedeutet "frei", 0 bedeutet "besetzt".</p>
            <div class="solution-box">
                <h4>Beispiel Java-Semaphor</h4>
                <pre>
import java.util.concurrent.Semaphore;

// Initialisierung als Mutex (fair: FIFO-Warteschlange)
static Semaphore mutex = new Semaphore(1, true);

try {
    mutex.acquire(); // Entspricht Wait(S): Eintritt in krit. Abschnitt
    // ... kritischer Abschnitt ...
} catch (InterruptedException e) {
    // ...
} finally {
    mutex.release(); // Entspricht Signal(S): Austritt
}
                </pre>
            </div>
            <h2 id="monitore">Monitore</h2>
            <p>Ein Monitor ist ein höheres, objektorientiertes Synchronisationskonzept. Er kapselt Daten zusammen mit den Methoden, die darauf operieren. Der entscheidende Punkt ist, dass der Compiler automatisch dafür sorgt, dass sich zu jedem Zeitpunkt nur ein Thread innerhalb einer der Monitormethoden aufhalten kann. Die Methoden sind also implizit durch einen Mutex geschützt.</p>
            <h4>Bedingungsvariablen</h4>
            <p>Um innerhalb eines Monitors eine Kooperation zu ermöglichen (z.B. ein Verbraucher muss warten, bis ein Erzeuger Daten bereitgestellt hat), gibt es Bedingungsvariablen. Diese bieten typischerweise zwei Operationen:
            <ul>
                <li><code>wait()</code>: Der aufrufende Thread gibt die Monitorsperre frei und blockiert, bis er von einem anderen Thread geweckt wird.</li>
                <li><code>notify() / notifyAll()</code>: Weckt einen (notify) oder alle (notifyAll) Threads, die auf derselben Bedingungsvariable warten.</li>
            </ul></p>
            <div class="solution-box">
                <h4>Beispiel Java-Monitor</h4>
                <p>In Java kann jede Klasse als Monitor fungieren. Das Schlüsselwort <code>synchronized</code> vor einer Methode macht diese zu einer Monitormethode. Die Methoden <code>wait()</code>, <code>notify()</code> und <code>notifyAll()</code> sind in der `Object`-Klasse definiert.</p>
                <pre>
// 'synchronized' macht die Methode zu einem kritischen Abschnitt
public synchronized void transfer(int amount) throws InterruptedException {
    // Warten, solange der Puffer leer ist
    while (buffer.isEmpty()) {
        wait(); // Gibt die Sperre ab und blockiert
    }
    // ... Verarbeitung ...
    // Einen wartenden Thread aufwecken
    notifyAll();
}
                </pre>
            </div>
            <h2>Klassische Probleme</h2>
            <h4>Erzeuger-Verbraucher (Producer-Consumer)</h4>
            <p>Ein oder mehrere Erzeuger-Threads produzieren Daten und legen sie in einem begrenzten Puffer ab. Ein oder mehrere Verbraucher-Threads entnehmen die Daten aus dem Puffer. Die Synchronisation muss sicherstellen, dass Erzeuger nicht in einen vollen und Verbraucher nicht aus einem leeren Puffer zugreifen, und dass der Zugriff auf den Puffer selbst wechselseitig ausgeschlossen ist.</p>
            <h4>Leser-Schreiber</h4>
            <p>Mehrere Threads greifen auf eine gemeinsame Datenstruktur zu. Dabei dürfen beliebig viele Leser gleichzeitig zugreifen. Sobald aber ein Schreiber zugreifen will, muss er exklusiven Zugriff erhalten; keine anderen Leser oder Schreiber dürfen aktiv sein.</p>
            <h4>Barriere / Rendezvous</h4>
            <p>Eine Gruppe von N Threads muss an einem bestimmten Punkt im Code (der Barriere) aufeinander warten. Keiner der Threads darf fortfahren, bevor nicht alle N Threads die Barriere erreicht haben. Dies kann mit einem Zähler, einem Mutex-Semaphor zum Schutz des Zählers und einem zweiten Semaphor als eigentliche Barriere implementiert werden.</p>
            <h2>Generelle Semaphore</h2>
            <p>Ein Semaphor, dessen Zähler beliebige ganze Zahlen annehmen kann.
            <ul>
                <li><code>Wait(S):</code> Dekrementiert S. Wenn S danach negativ ist, wird der Prozess blockiert. Die absolute Höhe des negativen Werts entspricht der Anzahl der wartenden Prozesse.</li>
                <li><code>Signal(S):</code> Inkrementiert S. Wenn S danach nicht positiv ist (d.h. ≤ 0), wird ein wartender Prozess deblockiert.</li>
            </ul></p>
            <h2>Synchronisationsdienste in UNIX/Linux</h2>
            <h4>POSIX-Thread-Mutex</h4>
            <pre>
#include <pthread.h>

pthread_mutex_t my_mutex = PTHREAD_MUTEX_INITIALIZER;

pthread_mutex_lock(&my_mutex);
// kritischer Abschnitt
pthread_mutex_unlock(&my_mutex);
            </pre>
            <h4>System-V-Semaphoren</h4>
            <pre>
int semid = semget(key, 1, IPC_CREAT | 0666);
semctl(semid, 0, SETVAL, initialValue);

// Wait
struct sembuf op = {0, -1, 0};
semop(semid, &op, 1);
// Signal
op.sem_op = +1;
semop(semid, &op, 1);
            </pre>
            <h2>Synchronisationsdienste in Windows</h2>
            <h4>Kritische Abschnitte</h4>
            <pre>
CRITICAL_SECTION cs;
InitializeCriticalSection(&cs);
EnterCriticalSection(&cs);
// kritischer Abschnitt
LeaveCriticalSection(&cs);
            </pre>
            <h4>Mutex und Semaphore</h4>
            <pre>
HANDLE hMutex = CreateMutex(NULL, FALSE, NULL);
WaitForSingleObject(hMutex, INFINITE);
ReleaseMutex(hMutex);

HANDLE hSem = CreateSemaphore(NULL, initialCount, maxCount, NULL);
WaitForSingleObject(hSem, INFINITE);
ReleaseSemaphore(hSem, 1, NULL);
            </pre>
        </article>

        <section class="quiz-section">
            <form class="chapter-quiz" data-answer="b">
                <p>Welches Problem verhindert ein Mutex?</p>
                <label><input type="radio" name="q1" value="a"> <a class="quicklink" href="08_deadlocks.html#deadlock">Deadlock</a></label><br>
                <label><input type="radio" name="q1" value="b"> <a class="quicklink" href="06_synchronisation.html#race-condition">Datenrennen</a></label><br>
                <label><input type="radio" name="q1" value="c"> Paging</label><br>
                <button type="submit">Prüfen</button>
                <p class="quiz-result"></p>
            </form>
            <form class="chapter-quiz" data-answer="b">
                <p>Wie unterscheidet sich ein Semaphor von einer einfachen Sperre mit aktivem Warten (Busy Waiting)?</p>
                <label><input type="radio" name="q2" value="a"> Ein Semaphor ist grundsätzlich schneller.</label><br>
                <label><input type="radio" name="q2" value="b"> Ein Semaphor blockiert einen wartenden Prozess und gibt die CPU für andere Aufgaben frei.</label><br>
                <label><input type="radio" name="q2" value="c"> Nur ein Semaphor kann von mehreren Threads verwendet werden.</label><br>
                <button type="submit">Prüfen</button>
                <p class="quiz-result"></p>
            </form>
            <form class="chapter-quiz" data-answer="b">
                <p>Was ist ein "kritischer Abschnitt" (Critical Section)?</p>
                <label><input type="radio" name="q3" value="a"> Der Teil des Codes, der zuerst ausgeführt wird.</label><br>
                <label><input type="radio" name="q3" value="b"> Ein Codeabschnitt, der auf gemeinsame Ressourcen zugreift und nicht von mehr als einem Thread gleichzeitig ausgeführt werden darf.</label><br>
                <label><input type="radio" name="q3" value="c"> Code, der nur im Fehlerfall ausgeführt wird.</label><br>
                <button type="submit">Prüfen</button>
                <p class="quiz-result"></p>
            </form>
            <form class="chapter-quiz" data-answer="b">
                <p>Was ist ein Monitor im Kontext der Synchronisation?</p>
                <label><input type="radio" name="q4" value="a"> Ein Hardware-Gerät zur Prozessbeobachtung.</label><br>
                <label><input type="radio" name="q4" value="b"> Ein übergeordnetes Synchronisationskonstrukt, das Daten und Prozeduren kapselt und automatisch für gegenseitigen Ausschluss sorgt.</label><br>
                <label><input type="radio" name="q4" value="c"> Ein anderer Name für einen binären Semaphor.</label><br>
                <button type="submit">Prüfen</button>
                <p class="quiz-result"></p>
            </form>
            <form class="chapter-quiz" data-answer="c">
                <p>Was muss beim Erzeuger-Verbraucher-Problem (Producer-Consumer) synchronisiert werden?</p>
                <label><input type="radio" name="q5" value="a"> Nur der Zugriff des Erzeugers auf den Puffer.</label><br>
                <label><input type="radio" name="q5" value="b"> Nur der Zugriff des Verbrauchers auf den Puffer.</label><br>
                <label><input type="radio" name="q5" value="c"> Der Zugriff auf den gemeinsamen Puffer, um zu verhindern, dass Erzeuger in einen vollen und Verbraucher aus einem leeren Puffer zugreifen.</label><br>
                <button type="submit">Prüfen</button>
                <p class="quiz-result"></p>
            </form>
        </section>
    </main>
    <footer role="contentinfo">
        <div class="container">
            <p>Erstellt zur Unterstützung der Prüfungsvorbereitung. Viel Erfolg bei der Klausur!</p>
        </div>
    </footer>
    <script src="js/main.js"></script>
    <script src="js/quiz.js"></script>
</body>
</html>