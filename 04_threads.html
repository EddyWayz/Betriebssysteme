<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4. Threads - Lernportal Betriebssysteme</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Zilla+Slab:wght@700&display=swap" rel="stylesheet">
    <style>
        .page-nav {
            background-color: #f8f9fa;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
            font-family: var(--header-font);
        }
        .page-nav a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: bold;
        }
        .page-nav a:hover {
            text-decoration: underline;
        }
        .content-section h3 {
            font-family: var(--title-font);
            font-size: 1.8rem;
            color: #444;
            margin-top: 40px;
            margin-bottom: 20px;
        }
        .content-section h4 {
            font-family: var(--title-font);
            font-size: 1.4rem;
            color: var(--primary-color);
            margin-top: 30px;
        }
        blockquote {
            border-left: 4px solid var(--primary-color);
            padding-left: 20px;
            margin: 20px 0;
            font-style: italic;
            background-color: var(--secondary-color);
            padding: 15px 20px;
            border-radius: 0 5px 5px 0;
        }
        .image-placeholder {
            background-color: #f0f0f0;
            border: 1px dashed #ccc;
            padding: 20px;
            text-align: center;
            margin: 20px auto;
            border-radius: 5px;
            color: #888;
            max-width: 80%;
            display: block;
            font-family: var(--header-font);
        }
        code, pre {
            font-family: Consolas, 'Courier New', monospace;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        code {
            padding: 2px 5px;
        }
        pre {
            padding: 15px;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        .key-term {
            font-weight: bold;
            color: var(--primary-color);
        }
        table {
            width: 100%;
            margin-top: 20px;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid var(--border-color);
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: var(--secondary-color);
            font-family: var(--header-font);
        }
    </style>
</head>
<body>

    <nav class="site-nav">
        <div class="container">
        <button class="nav-toggle" aria-label="Menü umschalten">&#9776;</button>
            <a href="index.html">Zurück zur Übersicht</a>
            <a href="01_einfuehrung.html">1</a>
            <a href="02_grundlagen.html">2</a>
            <a href="03_prozesse.html">3</a>
            <a href="04_threads.html" class="active">4</a>
            <a href="05_scheduling.html">5</a>
            <a href="06_synchronisation.html">6</a>
            <a href="07_kommunikation.html">7</a>
            <a href="08_deadlocks.html">8</a>
            <a href="09_speicherverwaltung.html">9</a>
            <a href="10_dateisysteme.html">10</a>
        </div>
    </nav>

    <header>
        <div class="container">
            <h1>Kapitel 4: Threads</h1>
            <p>Leichtgewichtige Prozesse für effiziente Parallelität.</p>
        </div>
    </header>

    <main class="container">
        <article class="content-section">
            <h2>Was sind Threads?</h2>
            <p>Ein Thread (engl. für "Faden" im Sinne eines Ausführungsstrangs) ist die kleinste Ausführungseinheit, die von einem Betriebssystem-Scheduler verwaltet werden kann. Man kann sich Threads als <span class="key-term">"leichtgewichtige Prozesse"</span> vorstellen, die innerhalb eines "schwergewichtigen" Hauptprozesses laufen. Jeder Prozess hat mindestens einen Thread, kann aber auch mehrere beherbergen, die dann (konzeptionell) parallel zueinander ablaufen.</p>
            
            <h4>Gemeinsame vs. Eigene Ressourcen</h4>
            <p>Das entscheidende Merkmal von Threads ist die Aufteilung der Ressourcen:</p>
            <p><strong>Alle Threads desselben Prozesses TEILEN sich:</strong></p>
            <ul>
                <li>Den gesamten <strong>Adressraum</strong> des Prozesses.</li>
                <li>Daraus folgend: Den <strong>Programmcode</strong> und <strong>globale Variablen</strong>.</li>
                <li>Den <strong>Heap</strong> für dynamisch allokierte Objekte.</li>
                <li>Die <strong>Betriebsmittel</strong> des Prozesses wie geöffnete Dateien oder Netzwerkverbindungen.</li>
            </ul>
            <p><strong>Jeder Thread hat jedoch SEINE EIGENEN:</strong></p>
            <ul>
                <li>Einen eindeutigen <strong>Thread-Zustand</strong> (Aktiv, Bereit, Blockiert).</li>
                <li>Einen eigenen <strong>Programmzähler (PC)</strong> und einen eigenen Satz von <strong>CPU-Registern</strong>.</li>
                <li>Einen eigenen <strong>Stack (Kellerstapel)</strong> für lokale Variablen, Funktionsparameter und Rücksprungadressen.</li>
            </ul>

            <h3>Threads im Vergleich zu Prozessen</h3>
            <table>
                <thead>
                    <tr>
                        <th>Eigenschaft</th>
                        <th>Prozesse</th>
                        <th>Threads (innerhalb desselben Prozesses)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Gewicht / Overhead</strong></td>
                        <td>Schwergewichtig. Erzeugung und Kontextwechsel sind teuer (langsamer).</td>
                        <td>Leichtgewichtig. Erzeugung und Kontextwechsel sind billiger (schneller).</td>
                    </tr>
                    <tr>
                        <td><strong>Adressraum</strong></td>
                        <td>Jeder Prozess hat seinen eigenen, privaten Adressraum.</td>
                        <td>Teilen sich den Adressraum ihres Elternprozesses.</td>
                    </tr>
                    <tr>
                        <td><strong>Kommunikation</strong></td>
                        <td>Aufwändig. Benötigt explizite Interprozesskommunikation (IPC) wie Pipes oder Shared Memory.</td>
                        <td>Einfach. Können direkt über globale Variablen und gemeinsame Objekte kommunizieren.</td>
                    </tr>
                    <tr>
                        <td><strong>Schutz / Isolation</strong></td>
                        <td>Stark. Prozesse sind durch das BS voneinander isoliert. Ein Absturz betrifft nur den eigenen Prozess.</td>
                        <td>Schwach. Ein fehlerhafter Thread kann den gesamten Adressraum und damit alle anderen Threads im Prozess beschädigen oder zum Absturz bringen.</td>
                    </tr>
                </tbody>
            </table>

            <h3>Warum Threads verwenden? (Vorteile)</h3>
            <ul>
                <li><strong>Parallelisierung:</strong> Auf Multi-Core-CPUs können mehrere Threads eines Prozesses echt parallel ausgeführt werden, was die Anwendungsleistung erheblich steigern kann.</li>
                <li><strong>Reaktionsfähigkeit (Responsiveness):</strong> In Anwendungen mit grafischer Benutzeroberfläche (GUI) können langwierige Aufgaben (z.B. ein Dateidownload) in einen Hintergrund-Thread ausgelagert werden. Dadurch bleibt der Haupt-Thread (GUI-Thread) reaktionsfähig und die Anwendung "friert nicht ein".</li>
                <li><strong>Effiziente Ressourcennutzung:</strong> Die Erzeugung eines Threads ist deutlich ressourcenschonender als die eines ganzen Prozesses. Dies ist besonders in Server-Anwendungen wichtig, wo für jede Client-Anfrage schnell eine neue Ausführungseinheit gestartet werden muss.</li>
                <li><strong>Vereinfachte Kommunikation:</strong> Da Threads Daten teilen, ist der Informationsaustausch trivial im Vergleich zur komplexen IPC zwischen Prozessen.</li>
            </ul>

            <h3>Implementierungsmodelle: User-Threads vs. Kernel-Threads</h3>
            <div class="image-placeholder">[Diagramm: Gegenüberstellung von reinen User-Level-Threads, reinen Kernel-Level-Threads und einem kombinierten Modell.]</div>
            <h4>User-Level-Threads</h4>
            <p>Die gesamte Thread-Verwaltung (Erzeugung, Scheduling, Synchronisation) findet im User-Space durch eine Thread-Bibliothek statt. Das Betriebssystem weiß nichts von den einzelnen Threads; es sieht nur den einen Hauptprozess.</p>
            <ul>
                <li><strong>Vorteile:</strong>
                    <ul>
                        <li>Sehr schnelles Umschalten, da kein Wechsel in den Kernel-Modus nötig ist.</li>
                        <li>Funktioniert auch auf Betriebssystemen, die nativ keine Threads unterstützen.</li>
                        <li>Jede Anwendung kann ihren eigenen, optimierten Scheduling-Algorithmus verwenden.</li>
                    </ul>
                </li>
                <li><strong>Nachteile:</strong>
                    <ul>
                        <li>Ein <strong>blockierender Systemaufruf</strong> (z.B. Lesen von der Festplatte) eines einzigen Threads blockiert den gesamten Prozess und damit alle anderen Threads darin.</li>
                        <li>Echte Parallelität auf Multi-Core-Systemen ist <strong>nicht möglich</strong>, da das BS dem Prozess nur eine CPU zuweist.</li>
                    </ul>
                </li>
            </ul>

            <h4>Kernel-Level-Threads</h4>
            <p>Jeder Thread wird direkt vom Betriebssystem-Kernel verwaltet. Der Kernel kennt jeden Thread und plant (scheduled) ihn wie einen Prozess. Dies ist der Ansatz, der von modernen Betriebssystemen wie Windows und Linux verwendet wird.</p>
            <ul>
                <li><strong>Vorteile:</strong>
                    <ul>
                        <li>Ein blockierender Aufruf eines Threads blockiert nicht die anderen Threads desselben Prozesses.</li>
                        <li>Das Betriebssystem kann die Threads eines Prozesses echt parallel auf mehrere CPU-Kerne verteilen.</li>
                    </ul>
                </li>
                <li><strong>Nachteile:</strong>
                    <ul>
                        <li>Die Erzeugung und der Kontextwechsel sind langsamer als bei User-Threads, da jeder Vorgang einen Systemaufruf (Wechsel in den Kernel-Modus) erfordert.</li>
                    </ul>
                </li>
            </ul>
            <p><strong>Hardware-Unterstützung:</strong> Moderne CPUs mit <strong>Hyperthreading</strong> oder <strong>Multi-Core-Architekturen</strong> sind darauf ausgelegt, mehrere Threads effizient parallel auszuführen. Sie stellen mehrere Registersätze und Programmzähler bereit, was perfekt zum Konzept der Kernel-Threads passt.</p>

            <h3>Threads in Java</h3>
            <p>Java hat die Thread-Unterstützung tief in die Sprache und die Java Virtual Machine (JVM) integriert. Jedes Java-Programm läuft in mindestens einem Thread, dem sogenannten "main-thread".</p>
            
            <h4>Erzeugung von Java-Threads</h4>
            <p>Es gibt zwei primäre Wege, einen Thread zu deklarieren und zu erzeugen:</p>
            <ol>
                <li><strong>Das <code>Runnable</code>-Interface implementieren (bevorzugt):</strong> Man erstellt eine Klasse, die das Interface <code>Runnable</code> implementiert und dessen einzige Methode <code>public void run()</code> überschreibt. Ein Objekt dieser Klasse wird dann dem Konstruktor der <code>Thread</code>-Klasse übergeben. Dieser Ansatz ist flexibler, da die Klasse noch von einer anderen Klasse erben kann.</li>
                <li><strong>Die <code>Thread</code>-Klasse erweitern:</strong> Man leitet eine eigene Klasse von <code>Thread</code> ab und überschreibt die <code>run()</code>-Methode.</li>
            </ol>
            <p>In beiden Fällen enthält die <code>run()</code>-Methode den Code, der nebenläufig ausgeführt werden soll. Der Thread wird mit der Methode <code>start()</code> gestartet, nicht durch direkten Aufruf von <code>run()</code>!</p>

            <h4>Java-Thread Lebenszyklus</h4>
            <div class="image-placeholder">[Diagramm: Lebenszyklus eines Java-Threads]<br>Zustände: New --(start())--> Runnable <-->(Scheduler) Running --(sleep(), wait(), I/O)--> Blocked --(resume, notify)--> Runnable; Running --(run() endet)--> Terminated.</div>
            <ul>
                <li><strong>New:</strong> Der Thread wurde mit <code>new Thread()</code> erzeugt, aber <code>start()</code> wurde noch nicht aufgerufen.</li>
                <li><strong>Runnable:</strong> Der Thread ist bereit zur Ausführung und konkurriert um CPU-Zeit. Dies umfasst die Zustände "Bereit" und "Aktiv" aus dem BS-Modell.</li>
                <li><strong>Blocked / Waiting / Timed_Waiting:</strong> Der Thread ist temporär inaktiv, weil er auf eine Sperre wartet (Blocked), durch <code>wait()</code> oder <code>join()</code> auf ein Ereignis wartet (Waiting), oder mit <code>Thread.sleep()</code> für eine bestimmte Zeit pausiert (Timed_Waiting).</li>
                <li><strong>Terminated:</strong> Die <code>run()</code>-Methode wurde erfolgreich oder durch eine Ausnahme beendet. Der Thread kann nicht erneut gestartet werden.</li>
            </ul>

            <h4>Code-Beispiel 1: Einfache Thread-Erzeugung (`Threading.java`)</h4>
            <p>Dieses Beispiel zeigt, wie zwei Threads erzeugt werden, die nebenläufig unterschiedliche Zeichen auf der Konsole ausgeben. Die Ausgabe ist nicht-deterministisch und wird bei jedem Lauf anders durchmischt sein.</p>
            <pre>
public class Threading {
    // Methode, die von den Threads ausgeführt wird
    static void print_char(char ch) {
        for (int i=0; i<50; i++) {
            System.out.print(ch);
        }
    }

    public static void main(String[] args) {
        final char ch1 = '-', ch2 = '*';
        
        // Threads p1 und p2 erstellen (anonyme innere Klassen)
        Thread p1 = new Thread() {
            public void run() { print_char(ch1); }
        };
        Thread p2 = new Thread() {
            public void run() { print_char(ch2); }
        };
        
        // Threads starten
        p1.start(); 
        p2.start();

        // Warten, bis beide Threads beendet sind
        try {
            p1.join(); 
            p2.join();
        } catch(InterruptedException e) {};

        System.out.print(" END ");
    }
}
            </pre>

            <h4>Code-Beispiel 2: Problem des gemeinsamen Zugriffs (`Threading_shared_resource.java`)</h4>
            <p>Dieses Beispiel demonstriert eine <span class="key-term">Race Condition</span>. Beide Threads greifen auf dieselbe statische Variable <code>ch</code> zu. Da der Zugriff nicht synchronisiert ist, "stiehlt" ein Thread der Variable den Wert des anderen, bevor dieser ihn ausgeben kann.</p>
            <pre>
public class Threading_shared_resource {
    static char ch; // Gemeinsame Ressource

    // Thread 1 wird diese Methode aufrufen
    static void print_star() {	
        try {
            ch = '*';
            Thread.sleep(1); // Simuliert eine Unterbrechung
            System.out.print(ch);
        } catch(InterruptedException e) {};
    }

    // Thread 2 wird diese Methode aufrufen
    static void print_minus() {
        try {
            ch = '-';
            Thread.sleep(1); // Simuliert eine Unterbrechung
            System.out.print(ch);
        } catch(InterruptedException e) {};
    }

    public static void main(String[] args) {
        // ... (Erzeugung und Start der Threads wie oben) ...
    }
}
            </pre>
            <p>Mögliche Ausgabe: <code>--</code> oder <code>**</code> statt des erwarteten <code>*-</code>. Dies passiert, weil z.B. Thread 1 <code>ch</code> auf <code>*</code> setzt, dann aber unterbrochen wird. Thread 2 setzt <code>ch</code> auf <code>-</code>. Dann wird Thread 1 wieder aktiv und gibt das <code>ch</code> aus, das inzwischen den Wert <code>-</code> hat. Dieses Problem wird in Kapitel 6 (Synchronisation) gelöst.</p>


        </article>
    </main>

    <footer>
        <div class="container">
            <p>Erstellt zur Unterstützung der Prüfungsvorbereitung. Viel Erfolg bei der Klausur!</p>
        </div>
    </footer>

    <script src="js/main.js"></script>
</body>
</html>