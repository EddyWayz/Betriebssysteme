<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Kapitel 7 - Kommunikation."/>
    <title>7. Kommunikation - Lernportal Betriebssysteme</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Zilla+Slab:wght@700&display=swap" rel="stylesheet">
</head>
<body>

<nav class="site-nav" role="navigation" aria-label="Hauptnavigation"></nav>

    <header role="banner">
        <div class="container">
            <h1 id="kommunikation">Kapitel 7: Kommunikation und Kooperation</h1>
            <p>Wie Prozesse und Threads miteinander interagieren und Daten austauschen.</p>
        </div>
    </header>

    <main class="container" role="main">
        <article class="content-section">
            <h2>Grundlagen der Prozessinteraktion</h2>
            <p><a class="quicklink" href="03_prozesse.html#prozess">Prozesse</a> laufen selten isoliert ab. Für viele komplexe Aufgaben müssen sie zusammenarbeiten. Diese <span class="key-term">Interaktion</span> umfasst zwei Aspekte:</p>
            <ul>
                <li><strong><a class="quicklink" href="06_synchronisation.html#synchronisation">Synchronisation</a>:</strong> Die zeitliche Abstimmung der Abläufe, wie in Kapitel 6 behandelt.</li>
                <li><strong>Informationsaustausch:</strong> Die inhaltliche Abstimmung durch das Übertragen von Daten.</li>
            </ul>
            <p>Der Informationsaustausch selbst lässt sich in zwei grundlegende Modelle unterteilen:</p>
            <ol>
                <li><strong>Kommunikation (Nachrichtenaustausch):</strong> Ein asymmetrisches Modell, bei dem ein Sender explizit eine Nachricht an einen Empfänger schickt.</li>
                <li><strong>Kooperation (Gemeinsamer Speicher):</strong> Ein symmetrisches Modell, bei dem mehrere Prozesse auf einen gemeinsamen Datenbereich zugreifen und diesen modifizieren.</li>
            </ol>
            <p>Das Betriebssystem muss für beide Modelle Mechanismen bereitstellen, die als <span id="ipc" class="key-term">Inter-Process Communication (IPC)</span> zusammengefasst werden.</p>
            
            <h2>1. Kommunikation durch Nachrichtenaustausch</h2>
            <p>Beim nachrichtenbasierten Ansatz stellen Betriebssysteme primitive Operationen zur Verfügung, typischerweise <code>Send</code> und <code>Receive</code>. Die genaue Funktionsweise dieser Operationen wird durch den Synchronisationstyp und den Kanaltyp bestimmt.</p>

            <h4>Synchronisationstypen: Blockierend vs. Nicht-blockierend</h4>
            <p>Dies beschreibt, wie sich der aufrufende Prozess nach der Operation verhält.</p>
            <ul>
                <li><strong>Synchrones (blockierendes) Senden:</strong> Der sendende Prozess ruft <code>Send</code> auf und wird vom Scheduler blockiert, bis der Empfänger die Nachricht erhalten hat.
                    <ul>
                        <li><strong>Vorteil:</strong> Implizite Quittung, dass die Nachricht angekommen ist. Benötigt keinen Puffer.</li>
                        <li><strong>Nachteil:</strong> Der Sender ist für die Dauer der Übertragung blockiert und kann nichts anderes tun.</li>
                    </ul>
                </li>
                <li><strong>Asynchrones (nicht-blockierendes) Senden:</strong> Der <code>Send</code>-Aufruf kehrt sofort zurück und der Sender arbeitet weiter. Die Nachricht wird vom Betriebssystem zwischengepuffert.
                    <ul>
                        <li><strong>Vorteil:</strong> Sehr effizient für den Sender.</li>
                        <li><strong>Nachteil:</strong> Der Sender weiß nicht, ob und wann die Nachricht empfangen wurde. Benötigt potentiell große Puffer im BS.</li>
                    </ul>
                </li>
                <li><strong>Synchrones (blockierendes) Empfangen:</strong> Der empfangende Prozess ruft <code>Receive</code> auf und blockiert, bis eine Nachricht für ihn eintrifft. Dies ist das häufigste Modell.</li>
                <li><strong>Asynchrones (nicht-blockierendes) Empfangen:</strong> Der Empfänger wird nicht blockiert.
                    <ul>
                        <li><strong>Polling:</strong> Der Empfänger fragt aktiv in einer Schleife nach, ob neue Nachrichten da sind ("Busy Wait").</li>
                        <li><strong>Asynchroner Prozeduraufruf (Handler):</strong> Der Empfänger registriert eine Funktion ("Handler"), die vom Betriebssystem automatisch aufgerufen wird, wenn eine Nachricht eintrifft (ähnlich einem Interrupt).</li>
                    </ul>
                </li>
            </ul>

            <table>
              <caption>Gängige Kommunikationskombinationen</caption>
              <thead>
                <tr>
                  <th></th>
                  <th>Synchrones Senden (blockierend)</th>
                  <th>Asynchrones Senden (nicht-blockierend)</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><strong>Synchrones Empfangen (blockierend)</strong></td>
                  <td><strong>Rendezvous:</strong> Starke Synchronisation. Sender & Empfänger warten aufeinander.</td>
                  <td><strong>Standard Client-Server:</strong> Häufigste Form. Empfänger wartet auf Anfragen.</td>
                </tr>
                <tr>
                  <td><strong>Asynchrones Empfangen (nicht-blockierend)</strong></td>
                  <td>Ungebräuchlich.</td>
                  <td>Gebräuchlich für Polling oder asynchrone E/A-Beendigung.</td>
                </tr>
              </tbody>
            </table>

            <h4>Kanaltypen: Direkt vs. Indirekt</h4>
            <ul>
                <li><strong>Direkte Kommunikation:</strong> Die Kommunikation findet explizit zwischen benannten Prozessen statt (z.B. <code>Send(Prozess_B, nachricht)</code>). Dies ist meist eine 1:1-Beziehung.</li>
                <li><strong>Indirekte Kommunikation:</strong> Die Kommunikation erfolgt über eine Zwischeninstanz, die als <span class="key-term">Mailbox</span> oder <span class="key-term">Port</span> bezeichnet wird. Sender schicken Nachrichten an den Port, Empfänger lesen von dort. Dies entkoppelt Sender und Empfänger und ermöglicht N:M-Kommunikation.
                    <ul>
                        <li><strong>Auslieferungsvarianten:</strong>
                            <ul>
                                <li>FIFO-Auslieferung über alle Sender und Empfänger</li>
                                <li>Typisierte Auslieferung nach Nachrichtentyp oder Priorität</li>
                                <li>Selektive Auslieferung: Empfänger wählt Nachrichten selbst aus</li>
                            </ul>
                        </li>
                        <li><strong>Ports:</strong> Wenn eine Mailbox exklusiv einem Prozess zugeordnet ist, spricht man von einem Port (z.B. well-known Ports im TCP/IP).</li>
                    </ul>
                </li>
            </ul>

            <h4>Pipes (UNIX/Windows)</h4>
            <p>Eine Pipe ist ein gerichteter Kommunikationskanal, der einen Bytestrom nach dem <span class="key-term">FIFO-Prinzip</span> transportiert. Wenn ein Prozess in eine volle Pipe schreibt oder aus einer leeren Pipe liest, wird er blockiert.</p>
            <ul>
                <li><strong>Anonymous Pipes:</strong> Können nur zwischen verwandten Prozessen (Eltern/Kind) verwendet werden.</li>
                <li><strong>Named Pipes:</strong> Haben einen Namen im Dateisystem und können von beliebigen Prozessen für die Kommunikation verwendet werden.</li>
            </ul>

            <h4 id="mailboxes">Nachrichten-Warteschlangen (Mailboxes/Message Queues)</h4>
            <p>IPC-Dienste wie POSIX-Message-Queues oder System V Message Queues stellen Warteschlangen zur Verfügung:</p>
            <ul>
                <li><strong>FIFO oder Prioritäten:</strong> Nachrichten werden in Warteschlangen nach Reihenfolge oder Priorität geordnet.</li>
                <li><strong>Typisierte Queues:</strong> Empfänger können nur Nachrichten bestimmter Typen lesen.</li>
                <li><strong>Selektive Abholung:</strong> Empfänger kann gezielt Nachrichten aus der Queue wählen.</li>
            </ul>

            <h4>Sockets</h4>
            <p>Sockets sind generelle Kommunikationsendpunkte, häufig für Netzwerkprogrammierung, aber auch lokal über „Unix Domain Sockets“:</p>
            <ul>
                <li>Bidirektional, 1:N-Verbindungen, bytestream-orientiert.</li>
                <li>Unterstützung für TCP/IP und lokale Kommunikation.</li>
            </ul>

            <h4>Signale (UNIX)</h4>
            <p>Signale sind eine einfache, asynchrone Form der Benachrichtigung, um einen Prozess über ein Ereignis zu informieren. Die "Nachricht" ist dabei nur eine einfache Nummer (der Signaltyp).</p>
            <p>Typische Signale sind <code>SIGINT</code> (Strg+C), <code>SIGSEGV</code> (Speicherzugriffsfehler) oder <code>SIGTERM</code> (Beendigungsanforderung). Ein Prozess kann mit <code>sigaction()</code> einen eigenen <span class="key-term">Signal-Handler</span> registrieren, um auf ein Signal zu reagieren. Da der Handler den normalen Programmfluss unterbricht, sollte er sehr kurz sein und z.B. nur eine globale Variable (Flag) setzen, die im Hauptprogramm ausgewertet wird.</p>

            <h3>2. Kooperation durch gemeinsame Daten</h3>
            <p>Bei diesem Modell arbeiten Prozesse nicht durch Nachrichtenaustausch, sondern durch den direkten Lese- und Schreibzugriff auf gemeinsame Datenobjekte. Dies ist zwar sehr schnell, erfordert aber eine explizite Synchronisation durch den Programmierer, um Race Conditions zu verhindern.</p>

            <h4>Sperr- und Lock-Mechanismen</h4>
            <p>Gemeinsamer Zugriff erfordert Synchronisation auf Objekte:</p>
            <ul>
                <li><strong>Exclusive Write:</strong> Ein Schreiber, keine Leser.</li>
                <li><strong>Protected Write:</strong> Ein Schreiber, beliebig viele Leser.</li>
                <li><strong>Concurrent Write:</strong> Beliebig viele Schreiber und Leser.</li>
                <li><strong>Protected Read:</strong> Mehrere Leser, keine Schreiber.</li>
                <li><strong>Concurrent Read:</strong> Leser und Schreiber gleichzeitig erlaubt.</li>
            </ul>

            <h4 id="shared-memory">Shared Memory (Gemeinsamer Speicher)</h4>
            <p>Der effizienteste IPC-Mechanismus. Das Betriebssystem blendet (mapped) einen physischen Speicherbereich in die virtuellen <a class="quicklink" href="09_speicherverwaltung.html#adressraeume">Adressräume</a> mehrerer Prozesse ein. Die Prozesse können dann auf diesen Bereich zugreifen, als wäre es ihr eigener. Da der Kernel nicht bei jedem Datenaustausch involviert ist, ist die Kommunikation extrem schnell. Die Synchronisation muss aber zwingend über andere Mechanismen wie <a class="quicklink" href="06_synchronisation.html#semaphore">Semaphore</a> erfolgen.</p>
            <div class="solution-box">
                <h4>Praxisbeispiel: Shared Memory in UNIX (C-Code)</h4>
                <p>Der Code (aus <code>OS_7_Kommunikation.pdf</code>) zeigt die Erzeugung, das Anbinden (<code>shmat</code>), Beschreiben, erneute Anbinden an eine andere Adresse und das Freigeben eines Shared Memory Segments.</p>
                <pre>
#include <sys/shm.h>
// ...
int segment_id;
char* shared_memory;

// 1. Ein Shared Memory Segment anfordern
segment_id = shmget(IPC_PRIVATE, size, IPC_CREAT | ...);

// 2. Das Segment an den Adressraum des Prozesses anbinden
shared_memory = (char*) shmat(segment_id, 0, 0);

// 3. Auf den Speicher zugreifen
sprintf(shared_memory, "Hallo Welt!");

// 4. Das Segment wieder vom Adressraum lösen
shmdt(shared_memory);

// 5. Das Segment (wenn nicht mehr gebraucht) dem System zur Freigabe melden
shmctl(segment_id, IPC_RMID, 0);
                </pre>
            </div>
            <h4>Memory Mapping von Dateien</h4>
            <p>Alternative zu Shared Memory: Zugriff auf gemeinsame Dateien über <code>mmap()</code>, ähnlich wie bei Memory-Mapped Files.</p>

            <h3>3. IPC-Dienste in Windows</h3>
            <ul>
                <li><strong>Anonymous Pipes:</strong> Nur lokal auf einem Rechner, unidirektional, mittels <code>CreatePipe()</code> und File-Operationen.</li>
                <li><strong>Named Pipes:</strong> Rechnerübergreifend, bidirektional möglich (<code>PIPE_ACCESS_DUPLEX</code>), Systemaufrufe <code>CreateNamedPipe()</code> und File-Funktionen, unterstützt Byte- und Nachrichten-Modus.</li>
                <li><strong>Mailslots:</strong> Einfache Mailbox-Dienste mit Broadcast-Funktion (1:N), <code>CreateMailslot()</code> und File-Operationen.</li>
                <li><strong>Shared Memory:</strong> Ähnlich UNIX über File-Mapping mit <code>CreateFileMapping()</code> und <code>MapViewOfFile()</code>.</li>
            </ul>
        </article>

        <section class="quiz-section">
            <form class="chapter-quiz" data-answer="b">
                <p>Wie kommunizieren Prozesse auf demselben Rechner am effizientesten?</p>
                <label><input type="radio" name="q1" value="a"> HTTP</label><br>
                <label><input type="radio" name="q1" value="b"> Pipes</label><br>
                <label><input type="radio" name="q1" value="c"> DNS</label><br>
                <button type="submit">Prüfen</button>
                <p class="quiz-result"></p>
            </form>
            <form class="chapter-quiz" data-answer="b">
                <p>Was ist der größte Vorteil von Shared Memory als IPC-Mechanismus?</p>
                <label><input type="radio" name="q2" value="a"> Es ist die sicherste Methode.</label><br>
                <label><input type="radio" name="q2" value="b"> Es ist extrem schnell, da der Kernel nach dem Setup nicht mehr am Datenaustausch beteiligt ist.</label><br>
                <label><input type="radio" name="q2" value="c"> Es synchronisiert den Datenzugriff automatisch.</label><br>
                <button type="submit">Prüfen</button>
                <p class="quiz-result"></p>
            </form>
            <form class="chapter-quiz" data-answer="b">
                <p>Was ist eine "Pipe" im Kontext von IPC?</p>
                <label><input type="radio" name="q3" value="a"> Ein Werkzeug zur Fehlersuche im Netzwerkverkehr.</label><br>
                <label><input type="radio" name="q3" value="b"> Ein unidirektionaler Kommunikationskanal, der einen Bytestrom transportiert, typischerweise zwischen Eltern- und Kindprozess.</label><br>
                <label><input type="radio" name="q3" value="c"> Eine Hardwareverbindung zwischen zwei Computern.</label><br>
                <button type="submit">Prüfen</button>
                <p class="quiz-result"></p>
            </form>
            <form class="chapter-quiz" data-answer="b">
                <p>Was ist der Hauptunterschied zwischen direkter und indirekter Kommunikation?</p>
                <label><input type="radio" name="q4" value="a"> Direkte Kommunikation ist immer schneller.</label><br>
                <label><input type="radio" name="q4" value="b"> Bei direkter Kommunikation müssen sich Prozesse explizit benennen; bei indirekter Kommunikation nutzen sie eine gemeinsame Mailbox oder einen Port.</label><br>
                <label><input type="radio" name="q4" value="c"> Indirekte Kommunikation kann nur auf einem einzelnen Computer verwendet werden.</label><br>
                <button type="submit">Prüfen</button>
                <p class="quiz-result"></p>
            </form>
            <form class="chapter-quiz" data-answer="b">
                <p>Was ist ein Signal in einem UNIX-ähnlichen System?</p>
                <label><input type="radio" name="q5" value="a"> Ein großes Datenpaket zur Übertragung von Dateien.</label><br>
                <label><input type="radio" name="q5" value="b"> Eine einfache, asynchrone Benachrichtigung an einen Prozess über ein Ereignis, identifiziert durch eine Nummer.</label><br>
                <label><input type="radio" name="q5" value="c"> Eine Art von Semaphor.</label><br>
                <button type="submit">Prüfen</button>
                <p class="quiz-result"></p>
            </form>
        </section>
    </main>

    <footer role="contentinfo">
        <div class="container">
            <p>Erstellt zur Unterstützung der Prüfungsvorbereitung. Viel Erfolg bei der Klausur!</p>
        </div>
    </footer>

    <script src="js/main.js"></script>
    <script src="js/quiz.js"></script>
</body>
</html>