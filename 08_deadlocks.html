<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8. Deadlocks - Lernportal Betriebssysteme</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Zilla+Slab:wght@700&display=swap" rel="stylesheet">
    <style>
        .page-nav { background-color: #f8f9fa; padding: 10px 0; border-bottom: 1px solid var(--border-color); font-family: var(--header-font); }
        .page-nav a { color: var(--primary-color); text-decoration: none; font-weight: bold; }
        .page-nav a:hover { text-decoration: underline; }
        .content-section h3 { font-family: var(--title-font); font-size: 1.8rem; color: #444; margin-top: 40px; margin-bottom: 20px; }
        .content-section h4 { font-family: var(--title-font); font-size: 1.4rem; color: var(--primary-color); margin-top: 30px; }
        blockquote { border-left: 4px solid var(--primary-color); padding-left: 20px; margin: 20px 0; font-style: italic; background-color: var(--secondary-color); padding: 15px 20px; border-radius: 0 5px 5px 0; }
        .image-placeholder { background-color: #f0f0f0; border: 1px dashed #ccc; padding: 20px; text-align: center; margin: 20px auto; border-radius: 5px; color: #888; max-width: 80%; display: block; font-family: var(--header-font); }
        code, pre { font-family: Consolas, 'Courier New', monospace; background-color: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; }
        code { padding: 2px 5px; }
        pre { padding: 15px; overflow-x: auto; white-space: pre-wrap; font-size: 0.9em; }
        .key-term { font-weight: bold; color: var(--primary-color); }
        .condition-list { list-style-type: none; padding-left: 0; }
        .condition-list li { background-color: #f8f9fa; margin-bottom: 10px; padding: 15px; border-left: 5px solid var(--accent-color); }
    </style>
</head>
<body>

    <nav class="site-nav">
        <div class="container">
        <button class="nav-toggle" aria-label="Menü umschalten">&#9776;</button>
            <a href="index.html">Zurück zur Übersicht</a>
            <a href="01_einfuehrung.html">1</a>
            <a href="02_grundlagen.html">2</a>
            <a href="03_prozesse.html">3</a>
            <a href="04_threads.html">4</a>
            <a href="05_scheduling.html">5</a>
            <a href="06_synchronisation.html">6</a>
            <a href="07_kommunikation.html">7</a>
            <a href="08_deadlocks.html" class="active">8</a>
            <a href="09_speicherverwaltung.html">9</a>
            <a href="10_dateisysteme.html">10</a>
        </div>
    </nav>

    <header>
        <div class="container">
            <h1>Kapitel 8: Deadlocks (Verklemmungen)</h1>
            <p>Der fatale Stillstand, wenn Prozesse ewig aufeinander warten.</p>
        </div>
    </header>

    <main class="container">
        <article class="content-section">
            <h2>Was ist ein Deadlock?</h2>
            <blockquote>
                <strong>Definition:</strong> Eine Menge von Prozessen befindet sich in einem Deadlock, wenn jeder Prozess in der Menge auf ein Ereignis wartet, das nur von einem anderen Prozess in derselben Menge ausgelöst werden kann.
            </blockquote>
            <p>Da alle Prozesse warten, kann keiner von ihnen das Ereignis auslösen, auf das die anderen warten. Das Resultat ist ein permanenter Stillstand, den die Prozesse nicht von selbst auflösen können. Betroffene Ressourcen sind typischerweise <span class="key-term">nicht-verdrängbare (non-preemptible)</span> Ressourcen wie Drucker, Dateien oder Semaphore.</p>
            
            <h4>Klassisches Beispiel: Die speisenden Philosophen</h4>
            <div class="image-placeholder">[Bild: Fünf Philosophen am runden Tisch mit fünf Stäbchen dazwischen.]</div>
            <p>Fünf Philosophen sitzen am Tisch und tun zwei Dinge: denken oder essen. Zum Essen benötigt jeder Philosoph zwei Essstäbchen. Zwischen je zwei Philosophen liegt genau ein Stäbchen.<br>
            <strong>Deadlock-Szenario:</strong> Jeder Philosoph nimmt gleichzeitig das Stäbchen zu seiner Linken auf. Nun hält jeder Philosoph eine Ressource (ein Stäbchen) und wartet auf eine zweite (das rechte Stäbchen), die aber von seinem Nachbarn gehalten wird. Es entsteht eine zirkuläre Abhängigkeit, und kein Philosoph kann jemals mit dem Essen beginnen.</p>
            
            <h4>Deadlock im realen Leben</h4>
            <p>Ein anschauliches Beispiel findet sich im Schienenverkehr: Zwei Züge teilen sich eine eingleisige Strecke und gewähren sich gegenseitig Vorfahrt. Solange keiner nachgibt, bleibt das System blockiert. Ähnliche Situationen treten in Datenbanken auf, wenn Transaktionen sich gegenseitig sperren.</p>
            <p>Quelle: <a href="http://mcs109.bu.edu/site/?p=deadlock" target="_blank">mcs109.bu.edu Deadlock im realen Leben</a></p>

            <h3>Die vier notwendigen Bedingungen für einen Deadlock</h3>
            <p>Ein Deadlock kann nur dann auftreten, wenn <strong>alle vier</strong> der folgenden Bedingungen gleichzeitig erfüllt sind. Dies ist eine extrem wichtige Prüfungsfrage.</p>
            <ol class="condition-list">
                <li>
                    <strong>1. Wechselseitiger Ausschluss (Mutual Exclusion):</strong> Mindestens eine Ressource muss in einem nicht-teilbaren Modus gehalten werden. Nur ein Prozess kann die Ressource zu einem Zeitpunkt nutzen.
                </li>
                <li>
                    <strong>2. Halten und Warten (Hold and Wait):</strong> Ein Prozess hält mindestens eine Ressource, während er auf eine weitere Ressource wartet, die von einem anderen Prozess gehalten wird.
                </li>
                <li>
                    <strong>3. Keine vorzeitige Entziehung (No Preemption):</strong> Eine Ressource kann einem Prozess nicht gewaltsam entzogen werden. Sie muss vom haltenden Prozess explizit freigegeben werden.
                </li>
                <li>
                    <strong>4. Zirkuläres Warten (Circular Wait):</strong> Es existiert eine Kette von wartenden Prozessen {P₀, P₁, ..., Pₙ}, bei der P₀ auf eine Ressource von P₁ wartet, P₁ auf eine von P₂, ..., und Pₙ auf eine Ressource wartet, die von P₀ gehalten wird.
                </li>
            </ol>

            <h3>Der Betriebsmittelgraph (Resource-Allocation Graph)</h3>
            <p>Ein Betriebsmittelgraph ist ein gerichteter Graph, der den Zustand der Ressourcenvergabe im System visualisiert. Er besteht aus:</p>
            <ul>
                <li><strong>Prozessknoten</strong> (Kreise)</li>
                <li><strong>Ressourcenknoten</strong> (Rechtecke, mit Punkten für jede Instanz der Ressource)</li>
                <li><strong>Anforderungskanten (Request Edge):</strong> Ein Pfeil von einem Prozess zu einer Ressource (P → R).</li>
                <li><strong>Zuweisungskanten (Assignment Edge):</strong> Ein Pfeil von einer Ressource zu einem Prozess (R → P).</li>
            </ul>
            <div class="image-placeholder">[Diagramm: Beispiel für einen Betriebsmittelgraphen mit und ohne Zyklus.]<br>
            Links: P1 hält R1 und fordert R2 an. P2 hält R2 und fordert R1 an. → Ein Zyklus, also ein Deadlock.<br>
            Rechts: P1 fordert R1 an, P2 hält R1 und fordert R2 an, P3 hält R2. → Kein Zyklus, kein Deadlock.</div>
            <blockquote>
                <strong>Regel:</strong> Ein Zyklus im Betriebsmittelgraphen ist eine <em>notwendige</em>, aber nicht immer <em>hinreichende</em> Bedingung für einen Deadlock. Wenn jede Ressource nur eine Instanz hat, ist ein Zyklus hinreichend. Gibt es mehrere Instanzen, kann ein Zyklus bestehen, ohne dass ein Deadlock vorliegt.
            </blockquote>
            <div class="image-placeholder">[Komplexes Beispiel: Mehrere Prozesse (P1–P5) und Ressourcen (R1–R8), das zeigt, dass ein Zyklus nicht zwingend zu einem Deadlock führen muss, wenn Ressourcen mehrfach vorhanden sind.]</div>
            <p>Im obigen komplexeren Graph werden mehrere Ressourceninstanzen betrachtet. Ein Zyklus zeigt hier nicht zwingend einen Deadlock an, da Prozesse auf andere Instanzen derselben Ressource zugreifen können.</p>

            <h2>Strategien zum Umgang mit Deadlocks</h2>

            <h4>1. Ignorieren (Vogel-Strauß-Algorithmus)</h4>
            <p>Die einfachste Strategie ist, das Problem zu ignorieren. Man geht davon aus, dass Deadlocks so selten auftreten, dass der Aufwand für ihre Behandlung in keinem Verhältnis zum Nutzen steht. Wenn ein Deadlock doch einmal auftritt, wird das System manuell oder per Watchdog neu gestartet. Dies ist der gängige Ansatz in vielen Betriebssystemen.</p>

            <h4>2. Erkennung und Behebung (Detection and Recovery)</h4>
            <p>Das System lässt Deadlocks zu, verfügt aber über Mechanismen, um sie zu erkennen und aufzulösen.</p>
            <ul>
                <li><strong>Erkennung:</strong> Das Betriebssystem unterhält intern einen Betriebsmittelgraphen und nutzt Algorithmen wie Tiefensuche (DFS) oder Breitensuche (BFS), um Zyklusdetektion durchzuführen.</li>
                <li><strong>Behebung (Recovery):</strong>
                    <ul>
                        <li><strong>Prozesse beenden:</strong> Abbruch eines oder mehrerer Prozesse im Zyklus, bis der Deadlock aufgelöst ist.</li>
                        <li><strong>Ressourcenentzug (Preemption):</strong> Entzug einer Ressource und Zuweisung an einen anderen Prozess; erfordert Rollback des beraubten Prozesses.</li>
                    </ul>
                </li>
            </ul>

            <h4>3. Verhinderung (Prevention)</h4>
            <p>Hierbei wird strukturell verhindert, dass das System jemals in einen Deadlock-Zustand gerät, indem mindestens eine der notwendigen Bedingungen ausgeschlossen wird.</p>
            <ul>
                <li><strong>Mutual Exclusion aufheben:</strong> Selten möglich. Spooling kann dedizierte Ressourcen teilbar machen.</li>
                <li><strong>Hold and Wait aufheben:</strong> Prozesse müssen alle benötigten Ressourcen gleichzeitig anfordern oder freigeben, bevor sie neue anfragen.</li>
                <li><strong>No Preemption aufheben:</strong> Bei fehlender Verfügbarkeit werden alle gehaltenen Ressourcen freigegeben.</li>
                <li><strong>Circular Wait aufheben:</strong> Ressourcen eindeutig nummerieren und nur in aufsteigender Reihenfolge anfordern.</li>
                <li><strong>Spooling:</strong> Ein spezieller Spooler-Prozess verwaltet exklusiven Zugriff (z.B. Druckerspooler), wodurch Deadlocks bei dieser Ressource vermieden werden.</li>
                <li><strong>Hierarchische Synchronisation:</strong> Mehrere Ebenen kritischer Abschnitte und Sperrkonzepte in definierter Reihenfolge, um zyklische Abhängigkeiten zu vermeiden.</li>
            </ul>

            <h4>4. Vermeidung (Avoidance)</h4>
            <p>Diese dynamische Methode erfordert, dass jeder Prozess vorab seinen <span class="key-term">maximalen Ressourcenbedarf</span> deklariert. Das Betriebssystem prüft bei jeder Anfrage, ob die Zuteilung einen <span class="key-term">sicheren Zustand</span> erhält.</p>
            <ul>
                <li>Ein <strong>sicherer Zustand</strong> erlaubt eine Reihenfolge, in der alle Prozesse terminieren können.</li>
                <li>Ein <strong>unsicherer Zustand</strong> könnte zu einem Deadlock führen.</li>
            </ul>
            <p>Bekanntestes Verfahren: <span class="key-term">Banker's Algorithm</span>. In der Praxis selten verwendet, da der maximale Bedarf oft schwer vorherzusagen ist.</p>

            <h4>5. Weitere Anmerkungen</h4>
            <ul>
                <li><strong>Nach der Deadlock-Erkennung:</strong> Mögliche Maßnahmen: Rücknahme der letzten Anforderung, Zurücksetzen auf einen Checkpoint, Abbruch von Prozessen (z.B. geringste CPU-Zeit), Einsatz von Timeouts.</li>
                <li><strong>Timeouts (Watchdog):</strong> Prozesse setzen Timer, um bei Überschreitung automatisch Maßnahmen wie Neustart auszulösen.</li>
                <li><strong>Rolle des Programmierers:</strong> Robuste Systemarchitektur, definierte Sperrhierarchien und gründliche Analyse des Nebenläufigkeitsverhaltens sind entscheidend.</li>
            </ul>
        </article>
    </main>

    <footer>
        <div class="container">
            <p>Erstellt zur Unterstützung der Prüfungsvorbereitung. Viel Erfolg bei der Klausur!</p>
        </div>
    </footer>

    <script src="js/main.js"></script>
</body>
</html>
