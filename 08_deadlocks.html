<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Kapitel 8 - Deadlocks."/>
    <title>8. Deadlocks - Lernportal Betriebssysteme</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Zilla+Slab:wght@700&display=swap" rel="stylesheet">
</head>
<body>

<nav class="site-nav" role="navigation" aria-label="Hauptnavigation"></nav>

    <header>
        <div class="container">
            <h1>Kapitel 8: Deadlocks (Verklemmungen)</h1>
            <p>Der fatale Stillstand, wenn Prozesse ewig aufeinander warten.</p>
        </div>
    </header>

    <main class="container">
        <article class="content-section">
            <h2>Was ist ein Deadlock?</h2>
            <blockquote>
                <strong>Definition:</strong> Eine Menge von Prozessen befindet sich in einem Deadlock, wenn jeder Prozess in der Menge auf ein Ereignis wartet, das nur von einem anderen Prozess in derselben Menge ausgelöst werden kann.
            </blockquote>
            <p>Da alle Prozesse warten, kann keiner von ihnen das Ereignis auslösen, auf das die anderen warten. Das Resultat ist ein permanenter Stillstand, den die Prozesse nicht von selbst auflösen können. Betroffene Ressourcen sind typischerweise <span class="key-term">nicht-verdrängbare (non-preemptible)</span> Ressourcen wie Drucker, Dateien oder Semaphore.</p>
            
            <h4>Klassisches Beispiel: Die speisenden Philosophen</h4>
            <img src="images/placeholder.svg" class="illustration" alt="Bild: Fünf Philosophen am runden Tisch mit fünf Stäbchen dazwischen.">
            <p>Fünf Philosophen sitzen am Tisch und tun zwei Dinge: denken oder essen. Zum Essen benötigt jeder Philosoph zwei Essstäbchen. Zwischen je zwei Philosophen liegt genau ein Stäbchen.<br>
            <strong>Deadlock-Szenario:</strong> Jeder Philosoph nimmt gleichzeitig das Stäbchen zu seiner Linken auf. Nun hält jeder Philosoph eine Ressource (ein Stäbchen) und wartet auf eine zweite (das rechte Stäbchen), die aber von seinem Nachbarn gehalten wird. Es entsteht eine zirkuläre Abhängigkeit, und kein Philosoph kann jemals mit dem Essen beginnen.</p>
            
            <h4>Deadlock im realen Leben</h4>
            <p>Ein anschauliches Beispiel findet sich im Schienenverkehr oder bei Verkehrsstaus, wo sich Fahrzeuge gegenseitig blockieren. Ähnliche Situationen treten in Datenbanken auf, wenn Transaktionen sich gegenseitig sperren.</p>
            <p>Quelle: <a href="http://mcs109.bu.edu/site/?p=deadlock" target="_blank">mcs109.bu.edu Deadlock im realen Leben</a></p>

            <h3>Die vier notwendigen Bedingungen für einen Deadlock</h3>
            <p>Ein Deadlock kann nur dann auftreten, wenn <strong>alle vier</strong> der folgenden Bedingungen gleichzeitig erfüllt sind. Dies ist eine extrem wichtige Prüfungsfrage.</p>
            <ol class="condition-list">
                <li>
                    <strong>1. Wechselseitiger Ausschluss (Mutual Exclusion):</strong> Mindestens eine Ressource muss in einem nicht-teilbaren, exklusiven Modus gehalten werden. Nur ein Prozess kann die Ressource zu einem Zeitpunkt nutzen.
                </li>
                <li>
                    <strong>2. Halten und Warten (Hold and Wait):</strong> Ein Prozess hält mindestens eine Ressource, während er auf eine weitere Ressource wartet, die von einem anderen Prozess gehalten wird.
                </li>
                <li>
                    <strong>3. Keine vorzeitige Entziehung (No Preemption):</strong> Eine Ressource kann einem Prozess nicht gewaltsam entzogen werden. Sie muss vom haltenden Prozess explizit freigegeben werden.
                </li>
                <li>
                    <strong>4. Zirkuläres Warten (Circular Wait):</strong> Es existiert eine Kette von wartenden Prozessen {P₀, P₁, ..., Pₙ}, bei der P₀ auf eine Ressource von P₁ wartet, P₁ auf eine von P₂, ..., und Pₙ auf eine Ressource wartet, die von P₀ gehalten wird.
                </li>
            </ol>

            <h3>Der Betriebsmittelgraph (Resource-Allocation Graph)</h3>
            <p>Ein Betriebsmittelgraph ist ein gerichteter Graph, der den Zustand der Ressourcenvergabe im System visualisiert. Er besteht aus:</p>
            <ul>
                <li><strong>Prozessknoten</strong> (Kreise)</li>
                <li><strong>Ressourcenknoten</strong> (Rechtecke, mit Punkten für jede Instanz der Ressource)</li>
                <li><strong>Anforderungskanten (Request Edge):</strong> Ein Pfeil von einem Prozess zu einer Ressource (P → R).</li>
                <li><strong>Zuweisungskanten (Assignment Edge):</strong> Ein Pfeil von einer Ressource zu einem Prozess (R → P).</li>
            </ul>
            <img src="images/placeholder.svg" class="illustration" alt="Diagramm: Beispiel für einen Betriebsmittelgraphen mit und ohne Zyklus. Links: P1 hält R1 und fordert R2 an. P2 hält R2 und fordert R1 an. → Ein Zyklus, also ein Deadlock. Rechts: P1 fordert R1 an, P2 hält R1 und fordert R2 an, P3 hält R2. → Kein Zyklus, kein Deadlock.">
            <blockquote>
                <strong>Regel:</strong> Ein Zyklus im Betriebsmittelgraphen ist eine <em>notwendige</em> Bedingung für einen Deadlock. Wenn jede Ressource nur eine Instanz hat, ist ein Zyklus auch eine <em>hinreichende</em> Bedingung. Gibt es mehrere Instanzen, kann ein Zyklus bestehen, ohne dass ein Deadlock vorliegt.
            </blockquote>
            <img src="images/placeholder.svg" class="illustration" alt="Komplexes Beispiel: Mehrere Prozesse (P1–P5) und Ressourcen (R1–R8), das zeigt, dass ein Zyklus nicht zwingend zu einem Deadlock führen muss, wenn Ressourcen mehrfach vorhanden sind.">
            <p>Im obigen komplexeren Graph werden mehrere Ressourceninstanzen betrachtet. Ein Zyklus zeigt hier nicht zwingend einen Deadlock an, da Prozesse auf andere Instanzen derselben Ressource zugreifen können.</p>

            <h2>Strategien zum Umgang mit Deadlocks</h2>

            <h4>1. Ignorieren (Vogel-Strauß-Algorithmus)</h4>
            <p>Die einfachste Strategie ist, das Problem zu ignorieren. Man geht davon aus, dass Deadlocks so selten auftreten, dass der Aufwand für ihre Behandlung in keinem Verhältnis zum Nutzen steht. Wenn ein Deadlock doch einmal auftritt, wird das System manuell oder per Watchdog neu gestartet. Dies ist der gängige Ansatz in vielen Desktop-Betriebssystemen.</p>

            <h4>2. Erkennung und Behebung (Detection and Recovery)</h4>
            <p>Das System lässt Deadlocks zu, verfügt aber über Mechanismen, um sie zu erkennen und aufzulösen.</p>
            <ul>
                <li><strong>Erkennung:</strong> Das Betriebssystem unterhält intern einen Betriebsmittelgraphen und nutzt Algorithmen wie die Tiefensuche, um zyklische Wartebeziehungen zu finden.</li>
                <li><strong>Behebung (Recovery):</strong>
                    <ul>
                        <li><strong>Prozesse beenden:</strong> Abbruch eines oder mehrerer Prozesse im Zyklus, bis der Deadlock aufgelöst ist.</li>
                        <li><strong>Ressourcenentzug (Preemption):</strong> Entzug einer Ressource und Zuweisung an einen anderen Prozess; erfordert oft ein Zurücksetzen (Rollback) des beraubten Prozesses auf einen sicheren Zustand (Checkpoint).</li>
                    </ul>
                </li>
            </ul>

            <h4>3. Verhinderung (Prevention)</h4>
            <p>Hierbei wird strukturell sichergestellt, dass das System niemals in einen Deadlock-Zustand geraten kann, indem mindestens eine der vier notwendigen Bedingungen von vornherein ausgeschlossen wird.</p>
            <ul>
                <li><strong>Hold and Wait aufheben:</strong> Ein Prozess muss entweder alle benötigten Ressourcen auf einmal anfordern, oder er muss alle gehaltenen Ressourcen freigeben, bevor er eine neue anfordern darf.</li>
                <li><strong>Circular Wait aufheben:</strong> Alle Ressourcen werden eindeutig durchnummeriert. Prozesse dürfen Ressourcen nur in aufsteigender Reihenfolge der Ressourcennummern anfordern.</li>
                <li><strong>Spooling:</strong> Für exklusive Ressourcen wie Drucker wird ein Spooler-Prozess zwischengeschaltet. Anstatt direkt auf den Drucker zuzugreifen, geben Prozesse ihre Druckaufträge an den Spooler, der sie in einer Warteschlange verwaltet und nacheinander abarbeitet. Dies hebt den direkten gegenseitigen Ausschluss auf.</li>
                <li><strong>Hierarchische Synchronisation:</strong> Sperren werden in einer festgelegten hierarchischen Reihenfolge angefordert, um zyklische Abhängigkeiten zu vermeiden.</li>
            </ul>

            <h4>4. Vermeidung (Avoidance)</h4>
            <p>Diese dynamische Methode erfordert, dass jeder Prozess vorab seinen <span class="key-term">maximalen Ressourcenbedarf</span> deklariert. Das Betriebssystem prüft bei jeder Ressourcenanforderung, ob die Zuteilung das System in einem <span class="key-term">sicheren Zustand</span> belässt.</p>
            <ul>
                <li>Ein <strong>sicherer Zustand</strong> ist ein Zustand, von dem aus es mindestens eine Ausführungsreihenfolge gibt, in der alle Prozesse ihre Ressourcen erhalten und terminieren können, selbst im ungünstigsten Fall.</li>
                <li>Ein <strong>unsicherer Zustand</strong> ist ein Zustand, der potenziell zu einem Deadlock führen <em>kann</em>. Das Betriebssystem wird eine Ressourcenanforderung verweigern, wenn sie zu einem unsicheren Zustand führen würde.</li>
            </ul>
            <p>Das bekannteste Verfahren hierfür ist der <span class="key-term">Banker's Algorithm</span>. In der Praxis wird diese Methode selten verwendet, da der maximale Ressourcenbedarf oft schwer vorherzusagen ist.</p>

            <h4>5. Weitere Anmerkungen</h4>
            <ul>
                <li><strong>Nach der Deadlock-Erkennung:</strong> Mögliche Maßnahmen: Rücknahme der letzten Anforderung, Zurücksetzen auf einen Checkpoint, Abbruch von Prozessen (z.B. nach Kriterien wie geringste CPU-Zeit), Einsatz von Timeouts.</li>
                <li><strong>Timeouts (Watchdog):</strong> Prozesse, die zu lange auf eine Ressource warten, werden nach Ablauf einer Zeitspanne automatisch abgebrochen. Dies ist eine pragmatische, aber ungenaue Methode.</li>
                <li><strong>Rolle des Programmierers:</strong> Eine robuste Systemarchitektur, definierte Sperrhierarchien und eine gründliche Analyse des Nebenläufigkeitsverhaltens sind entscheidend, um Deadlocks auf Anwendungsebene zu verhindern.</li>
            </ul>
        </article>
    </main>

    <footer>
        <div class="container">
            <p>Erstellt zur Unterstützung der Prüfungsvorbereitung. Viel Erfolg bei der Klausur!</p>
        </div>
    </footer>

    <script src="js/main.js"></script>
</body>
</html>