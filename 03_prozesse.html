<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3. Prozesse - Lernportal Betriebssysteme</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Zilla+Slab:wght@700&display=swap" rel="stylesheet">
    <style>
        .page-nav { background-color: #f8f9fa; padding: 10px 0; border-bottom: 1px solid var(--border-color); font-family: var(--header-font); }
        .page-nav a { color: var(--primary-color); text-decoration: none; font-weight: bold; }
        .page-nav a:hover { text-decoration: underline; }
        .content-section h3 { font-family: var(--title-font); font-size: 1.8rem; color: #444; margin-top: 40px; margin-bottom: 20px; }
        .content-section h4 { font-family: var(--title-font); font-size: 1.4rem; color: var(--primary-color); margin-top: 30px; }
        blockquote { border-left: 4px solid var(--primary-color); padding-left: 20px; margin: 20px 0; font-style: italic; background-color: var(--secondary-color); padding: 15px 20px; border-radius: 0 5px 5px 0; }
        .image-placeholder { background-color: #f0f0f0; border: 1px dashed #ccc; padding: 20px; text-align: center; margin: 20px auto; border-radius: 5px; color: #888; max-width: 80%; display: block; font-family: var(--header-font); }
        code { background-color: #e9ecef; color: #c7254e; padding: 2px 6px; border-radius: 3px; font-size: 0.9em; }
        .key-term { font-weight: bold; color: var(--primary-color); }
    </style>
</head>
<body>
        <nav class="site-nav">
        <div class="container">
            <a href="index.html">Zurück zur Übersicht</a>
            <a href="01_einfuehrung.html">1</a>
            <a href="02_grundlagen.html" class="active">2</a>
            <a href="03_prozesse.html">3</a>
            <a href="04_threads.html">4</a>
            <a href="05_scheduling.html">5</a>
            <a href="06_synchronisation.html">6</a>
            <a href="07_kommunikation.html">7</a>
            <a href="08_deadlocks.html">8</a>
            <a href="09_speicherverwaltung.html">9</a>
            <a href="10_dateisysteme.html">10</a>
        </div>
    </nav>
    <header>
        <div class="container">
            <h1>Kapitel 3: Prozesse</h1>
            <p>Das zentrale Konzept zur Verwaltung von Programmausführungen.</p>
        </div>
    </header>
    <main class="container">
        <article class="content-section">
            <h2>Was ist ein Prozess?</h2>
            <p>Ein Prozess ist eines der fundamentalsten Konzepte eines Betriebssystems. Er repräsentiert die <span class="key-term">aktive Ablaufinstanz eines Programms</span>. Während ein Programm auf der Festplatte nur eine passive Ansammlung von Befehlen ist, ist ein Prozess dieses Programm, nachdem es in den Speicher geladen wurde und von der CPU ausgeführt wird.</p>
            <p>Zu einem Prozess gehören alle Ressourcen, die zur Ausführung benötigt werden:</p>
            <ul>
                <li>Der <strong>Programmcode</strong> (Maschinenbefehle).</li>
                <li>Der aktuelle <strong>Prozesszustand</strong>, repräsentiert durch die Inhalte der CPU-Register (insbesondere Programmzähler und Prozessstatuswort).</li>
                <li>Zugeordnete <strong>Speicherbereiche</strong> (Textsegment, Datensegment, Heap, Stack).</li>
                <li>Weitere <strong>Betriebsmittel</strong> wie geöffnete Dateien, Netzwerkverbindungen oder E/A-Geräte.</li>
            </ul>

            <h3>Beispiel: Ein Programm als Prozess</h3>
            <p>Betrachten wir ein einfaches Programm, das eine Schleife ausführt:</p>
            <pre><code>R5 := 0       # z := 0
R6 := x       # Anzahl der Durchläufe
while R6 > 0:
    R5 := R5 + y   # z = z + y
    R6 := R6 - 1
end
z := R5</code></pre>
            <p>Während der Ausführung ändert sich der <span class="key-term">Prozesszustand</span> wie folgt:</p>
            <ul>
                <li><strong>Register:</strong> R5, R6, Programmzähler (PC) und Programmstatuswort (PSW).</li>
                <li><strong>Speicher:</strong> Werte von x, y und z im Hauptspeicher.</li>
            </ul>
            <div class="image-placeholder">[Diagramm: Ablauf der Prozessausführung am Beispiel einer Schleife mit PC und PSW]</div>

            <h3>Prozess speichern und reaktivieren</h3>
            <p>Ein Prozess lässt sich an einem beliebigen Punkt unterbrechen, sein Zustand (PC, Register, Speicherzuweisungen) wird im PCB gesichert und kann später exakt an dieser Stelle fortgesetzt werden. Diese Fähigkeit bildet die Grundlage für Multitasking und Kontextwechsel.</p>

            <h3>Viele Prozesse auf einem Rechner</h3>
            <p>Zu jedem Zeitpunkt existieren auf einem Rechner viele Prozesse:</p>
            <ul>
                <li>Einige Prozesse sind <strong>aktiv</strong> und erhalten CPU-Zeit.</li>
                <li>Viele Prozesse sind <strong>passiv</strong> (blockiert, warten auf Ereignisse).</li>
            </ul>
            <p>Das Betriebssystem ist verantwortlich für die <span class="key-term">Prozessverwaltung</span>, insbesondere für das Scheduling der CPU.</p>

            <h3>Der Prozesskontrollblock (Process Control Block, PCB)</h3>
            <p>Um die vielen laufenden Prozesse verwalten zu können, legt das Betriebssystem für jeden einzelnen Prozess einen <span class="key-term">Prozesskontrollblock (PCB)</span> an. Dieser enthält alle essentiellen Informationen, um den Prozess zu steuern und seinen Zustand bei einer Unterbrechung zu sichern.</p>
            <p>Typische Inhalte eines PCB sind:</p>
            <ul>
                <li><strong>Prozess-ID (PID):</strong> Ein eindeutiger Identifikator.</li>
                <li><strong>Prozesszustand:</strong> Neu, bereit, aktiv, blockiert, terminiert.</li>
                <li><strong>Programmzähler (PC):</strong> Nächste Befehlsadresse.</li>
                <li><strong>CPU-Register:</strong> Registerinhalte wie Akkumulator, Adressregister, PSW, Stack-Pointer.</li>
                <li><strong>Speicherverwaltungsinformationen:</strong> Zeiger auf Segment- oder Seitentabellen.</li>
                <li><strong>Priorität, Verzeichnis von offenen Dateien, Statistikdaten, etc.</strong></li>
            </ul>

            <h3>Prozesszustände und Zustandsübergänge</h3>
            <div class="image-placeholder">[Diagramm: Das 5-Zustands-Modell für Prozesse mit Übergängen zwischen Neu, Bereit, Aktiv, Blockiert und Terminiert]</div>
            <h4>Das 5-Zustands-Modell</h4>
            <ol>
                <li><strong>Neu (New):</strong> Prozess wird erzeugt.</li>
                <li><strong>Bereit (Ready):</strong> Wartet auf CPU-Zuteilung.</li>
                <li><strong>Aktiv (Running):</strong> CPU führt den Prozess aus.</li>
                <li><strong>Blockiert (Blocked/Waiting):</strong> Wartet auf externe Ereignisse.</li>
                <li><strong>Terminiert (Terminated):</strong> Prozess ist beendet, Ressourcen werden freigegeben.</li>
            </ol>
            <h4>Zustandsübergänge</h4>
            <ul>
                <li>Neu &rarr; Bereit: Initialisierung abgeschlossen.</li>
                <li>Bereit &rarr; Aktiv: Scheduler dispatcht den Prozess.</li>
                <li>Aktiv &rarr; Bereit: <strong>Verdrängung (Preemption)</strong> durch Zeitscheibe oder höheren Prioritätsprozess.</li>
                <li>Aktiv &rarr; Blockiert: Wartet auf Ressource/Ereignis.</li>
                <li>Blockiert &rarr; Bereit: Ereignis eingetreten.</li>
                <li>Aktiv &rarr; Terminiert: Prozess endet freiwillig oder durch Fehler.</li>
            </ul>
            <h4>Beispiel für Zustandswechsel bei Kommunikation</h4>
            <p>Ein kommunizierender Prozess wechselt zwischen Aktiv, Blockiert und Bereit, wenn er Nachrichten sendet/empfängt:</p>
            <div class="image-placeholder">[Diagramm: Zustandswechsel eines kommunizierenden Prozesses]</div>
            <h4>Warum Verdrängung sinnvoll ist</h4>
            <p>Verdrängung sorgt für gerechte CPU-Verteilung (Fairness) und schnelle Reaktionszeiten, da keine Prozesse die CPU monopolisiert.</p>

            <h3>Kontextwechsel (Context Switch)</h3>
            <blockquote>
                <strong>Ablauf eines Kontextwechsels (P1 &rarr; P2):</strong>
                <ol>
                    <li>Timer-Interrupt oder Systemaufruf tritt auf.</li>
                    <li>Hardware sichert PC und PSW, Wechsel in Kernel-Modus.</li>
                    <li>Dispatcher speichert restliche Register von P1 im PCB ab.</li>
                    <li>Scheduler wählt P2 zur Ausführung aus.</li>
                    <li>Dispatcher lädt Register von P2 aus dessen PCB.</li>
                    <li>Programmzähler wird gesetzt, Wechsel zurück in User-Modus.</li>
                    <li>P2 setzt Ausführung fort.</li>
                </ol>
            </blockquote>

            <h3>Beispiel: Programmzähler-Abfolge bei 3 Prozessen</h3>
            <div class="image-placeholder">[Diagramm: Ablauf der Programmzähler-Abfolge bei drei Prozessen und Dispatcher]</div>

            <h3>Beispiel: CPU-Zeitscheiben-Diagramm</h3>
            <div class="image-placeholder">[Zeitdiagramm: CPU-Zeitverteilung zwischen Prozess 3, Prozess 2, Prozess 1 und Dispatcher]</div>

            <h3>Beispiel: Task Manager</h3>
            <div class="image-placeholder">[Screenshot: Windows 10 Task-Manager mit laufenden Prozessen]</div>

            <h3>Prozesserzeugung</h3>
            <h4>Wege der Prozesserzeugung</h4>
            <ul>
                <li><strong>Systemstart:</strong> Daemons/Services werden initialisiert.</li>
                <li><strong>Benutzeraktion:</strong> Klick oder Konsolenbefehl.</li>
                <li><strong>Von anderen Prozessen:</strong> <code>fork()</code> (UNIX), <code>CreateProcess()</code> (Windows).</li>
            </ul>
            <h4>Anwendungsfall: Prozess-Pipelining</h4>
            <p>Aufteilung einer Aufgabe in eine Kette von Teilprozessen (Producer-Consumer):</p>
            <ul>
                <li><strong>Modularität</strong> und bessere Testbarkeit.</li>
                <li><strong>Parallele Ausführung</strong> erhöht den Gesamtdurchsatz.</li>
            </ul>
            <div class="image-placeholder">[Diagramm: Flugsicherungs-Beispiel als Prozess-Pipeline]</div>
            <h4>Beispielrechnung zum Prozess-Pipelining</h4>
            <p>Vergleich des Durchsatzes ohne und mit Pipelining anhand von I/O- und Rechenzeiten.</p>
            <div class="image-placeholder">[Diagramm: Vergleich der Plot-Verarbeitung mit und ohne Pipelining]</div>

            <h3>Erweiterte Prozesshierarchie (Flugsicherung)</h3>
            <p>Komplexes System mit mehreren spezialisierten Prozessen:</p>
            <div class="image-placeholder">[Diagramm: Prozessfamilie Flugsicherung mit GUI-, Recording- und Supervision-Prozessen]</div>

            <h3>Prozessterminierung</h3>
            <p>Ein Prozess endet durch:</p>
            <ul>
                <li><strong>Freiwilliges Beenden:</strong> <code>exit()</code> nach Abschluss.</li>
                <li><strong>Fehlerbehandlung:</strong> Kontrollierte Abbruch bei erkannter Ausnahme.</li>
                <li><strong>Unfreiwillige Terminierung:</strong> Abbruch durch das BS bei schwerwiegenden Fehlern.</li>
                <li><strong>Extern:</strong> Befehl wie <code>kill</code> (UNIX) oder <code>TerminateProcess</code> (Windows).</li>
            </ul>
        </article>
    </main>
    <footer>
        <div class="container">
            <p>Erstellt zur Unterstützung der Prüfungsvorbereitung. Viel Erfolg bei der Klausur!</p>
        </div>
    </footer>
    <script src="js/main.js"></script>
</body>
</html>
