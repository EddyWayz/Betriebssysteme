<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5. CPU-Scheduling - Lernportal Betriebssysteme</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Zilla+Slab:wght@700&display=swap" rel="stylesheet">
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [['$','$'], ['\\(','\\)']],
          displayMath: [['$$','$$'], ['\\[','\\]']],
          processEscapes: true
        }
      });
    </script>
    <style>
        .page-nav { background-color: #f8f9fa; padding: 10px 0; border-bottom: 1px solid var(--border-color); font-family: var(--header-font); }
        .page-nav a { color: var(--primary-color); text-decoration: none; font-weight: bold; }
        .page-nav a:hover { text-decoration: underline; }
        .content-section h2 { font-family: var(--title-font); font-size: 2rem; color: #333; margin-top: 30px; }
        .content-section h3 { font-family: var(--title-font); font-size: 1.6rem; color: #444; margin-top: 25px; margin-bottom: 15px; }
        .content-section h4 { font-family: var(--title-font); font-size: 1.3rem; color: var(--primary-color); margin-top: 20px; }
        blockquote { border-left: 4px solid var(--primary-color); padding-left: 20px; margin: 20px 0; font-style: italic; background-color: var(--secondary-color); padding: 15px 20px; border-radius: 0 5px 5px 0; }
        .image-placeholder { background-color: #f0f0f0; border: 1px dashed #ccc; padding: 20px; text-align: center; margin: 20px auto; border-radius: 5px; color: #888; max-width: 80%; display: block; font-family: var(--header-font); }
        code, pre { font-family: Consolas, 'Courier New', monospace; background-color: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; }
        code { padding: 2px 5px; }
        pre { padding: 15px; overflow-x: auto; white-space: pre-wrap; }
        .key-term { font-weight: bold; color: var(--primary-color); }
        table { width: 100%; margin-top: 20px; border-collapse: collapse; }
        th, td { border: 1px solid var(--border-color); padding: 12px; text-align: left; }
        th { background-color: var(--secondary-color); font-family: var(--header-font); }
        .gantt { border: 1px solid #ccc; padding: 10px; margin-top: 15px; font-family: monospace; white-space: pre; background: #fafafa; }
    </style>
</head>
<body>

    <nav class="site-nav">
        <div class="container">
        <button class="nav-toggle" aria-label="Men√º umschalten">&#9776;</button>
        <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Dark Mode umschalten">üåô</button>
            <a href="index.html">Zur√ºck zur √úbersicht</a>
            <a href="01_einfuehrung.html">1</a>
            <a href="02_grundlagen.html">2</a>
            <a href="03_prozesse.html">3</a>
            <a href="04_threads.html">4</a>
            <a href="05_scheduling.html" class="active">5</a>
            <a href="06_synchronisation.html">6</a>
            <a href="07_kommunikation.html">7</a>
            <a href="08_deadlocks.html">8</a>
            <a href="09_speicherverwaltung.html">9</a>
            <a href="10_dateisysteme.html">10</a>
        </div>
    </nav>

    <header>
        <div class="container">
            <h1>Kapitel 5: CPU-Scheduling</h1>
            <p>Die Kunst, zu entscheiden, welcher Prozess als N√§chstes die CPU erh√§lt.</p>
        </div>
    </header>

    <main class="container">
        <article class="content-section">

            <h2>Die Rolle und Ziele des Schedulers</h2>
            <p>Der <span class="key-term">Scheduler</span> (oder Dispatcher) ist die Komponente, die bestimmt, welcher Prozess als n√§chstes die CPU erh√§lt. Entscheidungen fallen bei Zustandswechseln, z.B. wenn ein aktiver Prozess blockiert wird, ein Prozess seine Zeitscheibe aufgebraucht hat oder neue Prozesse in die Ready-Queue kommen.</p>
            <h3>Kriterien und Zielkonflikte</h3>
            <p>Ein Scheduler muss verschiedene, teils widerspr√ºchliche Ziele ausbalancieren:</p>
            <ul>
                <li><strong>CPU-Auslastung:</strong> Die CPU soll m√∂glichst dauerhaft besch√§ftigt sein.</li>
                <li><strong>Durchsatz:</strong> Maximierung der Anzahl abgeschlossener Prozesse pro Zeiteinheit.</li>
                <li><strong>Antwortzeit:</strong> Minimale Zeit von der Anforderung bis zur ersten sichtbaren Reaktion.</li>
                <li><strong>Fairness:</strong> Kein Prozess darf "verhungern", also unangemessen lange auf CPU-Zeit warten.</li>
                <li><strong>Stabilit√§t:</strong> Vorhersehbares und kontrolliertes Verhalten auch bei hoher Systemlast.</li>
                <li><strong>Deadline-Einhaltung:</strong> In Echtzeitsystemen ist die Einhaltung von Fristen das oberste Kriterium.</li>
            </ul>
            <blockquote><strong>Overhead:</strong> Scheduling selbst verbraucht CPU-Zeit. Zu komplexe Algorithmen k√∂nnen kontraproduktiv sein, da der Aufwand f√ºr die Entscheidungsfindung die gewonnene Effizienz √ºbersteigen kann.</blockquote>

            <h2>Leistungskennzahlen</h2>
            <ul>
                <li><strong>CPU-Auslastung</strong></li>
                <li><strong>Durchsatz (Throughput)</strong></li>
                <li><strong>Turnaround Time</strong> (Verweilzeit)</li>
                <li><strong>Wartezeit (Waiting Time)</strong></li>
                <li><strong>Antwortzeit (Response Time)</strong></li>
            </ul>

            <h2>Grundlegende Scheduling-Algorithmen</h2>

            <h3>First-Come, First-Served (FCFS)</h3>
            <ul>
                <li>Nicht-pr√§emptiv: Ein Prozess gibt die CPU erst ab, wenn er blockiert oder fertig ist.</li>
                <li>Einfach, aber anf√§llig f√ºr den "Konvoi-Effekt", bei dem kurze Prozesse hinter einem langen Prozess warten m√ºssen, was die durchschnittliche Wartezeit erh√∂ht.</li>
            </ul>
            <div class="gantt">Beispiel: P1(24), P2(3), P3(3)<br>|---P1(24)---|--P2(3)--|--P3(3)--|<br>√ò Wartezeit = (0 + 24 + 27) / 3 = 17</div>

            <h3>Shortest-Job-First (SJF) / Shortest-Remaining-Time (SRT)</h3>
            <ul>
                <li>W√§hlt den Prozess mit der k√ºrzesten gesch√§tzten Ausf√ºhrungszeit aus.</li>
                <li>Die pr√§emptive Variante hei√üt <strong>Shortest-Remaining-Time (SRT)</strong> und wechselt den Prozess, wenn ein neuer Prozess mit einer k√ºrzeren verbleibenden Laufzeit ankommt.</li>
                <li>Optimal bez√ºglich der minimalen durchschnittlichen Wartezeit, aber es besteht die Gefahr des Verhungerns f√ºr lange Prozesse.</li>
            </ul>
            <div class="gantt">Ablauf (SJF nicht-pr√§emptiv, Start bei t=0): P1(6), P2(8), P3(7), P4(3)<br>|--P4(3)--|---P1(6)---|---P3(7)---|----P2(8)----|<br>√ò Wartezeit = (3 + 16 + 9 + 0) / 4 = 7</div>

            <h3>Priorit√§tsbasiertes Scheduling</h3>
            <ul>
                <li>Prozesse erhalten Priorit√§ten (statisch oder dynamisch). Der Prozess mit der h√∂chsten Priorit√§t wird ausgew√§hlt.</li>
                <li>Meist pr√§emptiv: Ein ankommender Prozess mit h√∂herer Priorit√§t verdr√§ngt den laufenden Prozess.</li>
                <li>Problem: Verhungern von Prozessen mit niedriger Priorit√§t. L√∂sung: "Aging", bei dem die Priorit√§t wartender Prozesse mit der Zeit erh√∂ht wird.</li>
                <li>Problem: <strong>Priorit√§tsinversion</strong>. Ein Prozess hoher Priorit√§t wartet auf eine Ressource, die von einem Prozess niedriger Priorit√§t gehalten wird, welcher wiederum von einem Prozess mittlerer Priorit√§t verdr√§ngt wird. L√∂sung: Priority Inheritance oder Priority Ceiling.</li>
            </ul>

            <h3>Round Robin (RR)</h3>
            <ul>
                <li>Jeder Prozess erh√§lt eine feste Zeitscheibe (Quantum). Nach Ablauf des Quantums wird der Prozess verdr√§ngt und ans Ende der Ready-Queue gestellt.</li>
                <li>Fair und sorgt f√ºr gute Antwortzeiten, aber ein zu kleines Quantum f√ºhrt zu hohem Overhead durch h√§ufige Kontextwechsel.</li>
            </ul>
            <div class="gantt">Beispiel (Quantum=4): P1(24), P2(3), P3(3)<br>|P1(4)|P2(3)|P3(3)|P1(4)|P1(4)|P1(4)|P1(4)|P1(4)|</div>

            <h3>Multilevel Queue Scheduling</h3>
            <p>Mehrere separate Ready-Queues f√ºr verschiedene Prozessklassen (z.B. interaktive Vordergrundprozesse, Batch-Hintergrundprozesse). Jede Queue kann einen eigenen Scheduling-Algorithmus verwenden.</p>
            <div class="image-placeholder">[Diagramm: Ready Queues Hierarchie mit verschiedenen Priorit√§ten]</div>

            <h3>Multilevel Feedback Queue (MLFQ)</h3>
            <p>Wie Multilevel Queue, aber Prozesse k√∂nnen zwischen den Queues wechseln. Ein Prozess, der viel CPU-Zeit verbraucht, kann in eine niedrigere Priorit√§ts-Queue mit l√§ngerem Quantum verschoben werden. Dies verhindert Verhungern und passt sich dem Prozessverhalten an.</p>

            <h3>Echtzeit-Scheduling</h3>
            <h4>Earliest Deadline First (EDF)</h4>
            <p>Dynamisches, pr√§emptives Verfahren, das dem Prozess mit der fr√ºhesten Deadline die h√∂chste Priorit√§t gibt. Es ist optimal auf einem Prozessor, d.h., wenn eine Abfolge existiert, die alle Deadlines einh√§lt, wird EDF sie finden. Unter √úberlast kann es jedoch zu einem Dominoeffekt kommen, bei dem viele Tasks ihre Deadlines verpassen.</p>
            
            <h4>Rate Monotonic Scheduling (RMS)</h4>
            <p>Statisches, pr√§emptives Verfahren f√ºr periodische Tasks. Die Priorit√§t wird fest basierend auf der Periodendauer vergeben: je k√ºrzer die Periode, desto h√∂her die Priorit√§t. RMS ist optimal, solange die CPU-Auslastung eine bestimmte Schranke nicht √ºberschreitet: $\sum (C_i / P_i) \leq n(2^{1/n}-1)$, wobei C die Ausf√ºhrungszeit und P die Periode ist. F√ºr viele Prozesse konvergiert diese Schranke gegen $\ln(2) \approx 69.3\%$.</p>

            <h2>Scheduling in Mehrprozessorumgebungen</h2>
            <ul>
                <li><strong>Prozessoraffinit√§t:</strong> Prozesse sollten m√∂glichst auf derselben CPU bleiben, um die im lokalen Cache gehaltenen Daten weiter nutzen zu k√∂nnen und Cache-Invalidierungen zu minimieren.</li>
                <li><strong>Gang Scheduling:</strong> Gruppen von Threads, die eng zusammenarbeiten (eine "Gang"), werden gleichzeitig auf verschiedenen CPUs ausgef√ºhrt, um ineffiziente Wartezeiten zu vermeiden.</li>
            </ul>

            <h2>Scheduling in der Praxis</h2>
            <h3>Windows</h3>
            <ul>
                <li>Priorit√§tsbasiertes, pr√§emptives Scheduling mit 32 Priorit√§tsstufen.</li>
                <li>Dynamische Priorit√§tsanpassung: Interaktive Threads (z.B. nach einer E/A-Operation) erhalten einen Priorit√§ts-Boost, w√§hrend CPU-lastige Threads in der Priorit√§t abgesenkt werden.</li>
                <li>Ein "Priority Boost" wird auch f√ºr lange wartende Threads (Anti-Starvation) durchgef√ºhrt.</li>
            </ul>
            <h3>Linux</h3>
            <ul>
                <li>Echtzeit-Klassen (FIFO, RR) haben Vorrang vor allen anderen.</li>
                <li>Der Standard-Scheduler f√ºr Nicht-Echtzeit-Prozesse (CFS - Completely Fair Scheduler) zielt darauf ab, jedem Prozess einen fairen Anteil an der CPU-Zeit zu geben, wobei I/O-lastige Threads bevorzugt werden, um die Antwortzeiten zu verbessern.</li>
            </ul>

            <h2>Zusammenfassung</h2>
            <ul>
                <li>Es gibt viele Scheduling-Algorithmen mit spezifischen Vor- und Nachteilen.</li>
                <li>Die Wahl des Algorithmus h√§ngt stark vom Systemtyp ab: Batch, interaktiv oder Echtzeit.</li>
                <li>Die zentralen Herausforderungen sind die Trade-offs zwischen Durchsatz, Antwortzeiten, Fairness und dem eigenen Verwaltungsaufwand (Overhead).</li>
            </ul>

        </article>
    </main>

    <footer>
        <div class="container">
            <p>Erstellt zur Unterst√ºtzung der Pr√ºfungsvorbereitung. Viel Erfolg bei der Klausur!</p>
        </div>
    </footer>

    <script src="js/main.js"></script>
</body>
</html>