<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5. CPU-Scheduling - Lernportal Betriebssysteme</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Zilla+Slab:wght@700&display=swap" rel="stylesheet">
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [['$','$'], ['\\(','\\)']],
          displayMath: [['$$','$$'], ['\\[','\\]']],
          processEscapes: true
        }
      });
    </script>
    <style>
        .page-nav { background-color: #f8f9fa; padding: 10px 0; border-bottom: 1px solid var(--border-color); font-family: var(--header-font); }
        .page-nav a { color: var(--primary-color); text-decoration: none; font-weight: bold; }
        .page-nav a:hover { text-decoration: underline; }
        .content-section h2 { font-family: var(--title-font); font-size: 2rem; color: #333; margin-top: 30px; }
        .content-section h3 { font-family: var(--title-font); font-size: 1.6rem; color: #444; margin-top: 25px; margin-bottom: 15px; }
        .content-section h4 { font-family: var(--title-font); font-size: 1.3rem; color: var(--primary-color); margin-top: 20px; }
        blockquote { border-left: 4px solid var(--primary-color); padding-left: 20px; margin: 20px 0; font-style: italic; background-color: var(--secondary-color); padding: 15px 20px; border-radius: 0 5px 5px 0; }
        .image-placeholder { background-color: #f0f0f0; border: 1px dashed #ccc; padding: 20px; text-align: center; margin: 20px auto; border-radius: 5px; color: #888; max-width: 80%; display: block; font-family: var(--header-font); }
        code, pre { font-family: Consolas, 'Courier New', monospace; background-color: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; }
        code { padding: 2px 5px; }
        pre { padding: 15px; overflow-x: auto; white-space: pre-wrap; }
        .key-term { font-weight: bold; color: var(--primary-color); }
        table { width: 100%; margin-top: 20px; border-collapse: collapse; }
        th, td { border: 1px solid var(--border-color); padding: 12px; text-align: left; }
        th { background-color: var(--secondary-color); font-family: var(--header-font); }
        .gantt { border: 1px solid #ccc; padding: 10px; margin-top: 15px; font-family: monospace; white-space: pre; background: #fafafa; }
    </style>
</head>
<body>

    <nav class="site-nav">
        <div class="container">
            <a href="index.html">Zurück zur Übersicht</a>
            <a href="01_einfuehrung.html">1</a>
            <a href="02_grundlagen.html">2</a>
            <a href="03_prozesse.html">3</a>
            <a href="04_threads.html">4</a>
            <a href="05_scheduling.html" class="active">5</a>
            <a href="06_synchronisation.html">6</a>
            <a href="07_kommunikation.html">7</a>
            <a href="08_deadlocks.html">8</a>
            <a href="09_speicherverwaltung.html">9</a>
            <a href="10_dateisysteme.html">10</a>
        </div>
    </nav>

    <header>
        <div class="container">
            <h1>Kapitel 5: CPU-Scheduling</h1>
            <p>Die Kunst, zu entscheiden, welcher Prozess als Nächstes die CPU erhält.</p>
        </div>
    </header>

    <main class="container">
        <article class="content-section">

            <!-- Ziele und Kennzahlen -->
            <h2>Die Rolle und Ziele des Schedulers</h2>
            <p>Der <span class="key-term">Scheduler</span> (oder Dispatcher) entscheidet, welcher bereite Prozess die CPU erhält. Entscheidungen fallen bei Zustandswechseln und neuen Prozessen.</p>
            <h3>Kriterien und Zielkonflikte</h3>
            <ul>
                <li><strong>CPU-Auslastung:</strong> CPU soll möglichst dauerhaft beschäftigt sein.</li>
                <li><strong>Durchsatz:</strong> Maximierung abgeschlossener Prozesse pro Zeiteinheit.</li>
                <li><strong>Antwortzeit:</strong> Minimale Zeit bis zur ersten Reaktion.</li>
                <li><strong>Fairness:</strong> Kein Prozess darf verhungern.</li>
                <li><strong>Stabilität:</strong> Vorhersagbarkeit auch bei hoher Last.</li>
                <li><strong>Deadline-Einhaltung:</strong> In Echtzeitsystemen oberstes Kriterium.</li>
            </ul>
            <blockquote><strong>Overhead:</strong> Scheduling selbst verbraucht CPU-Zeit; zu komplexe Algorithmen können kontraproduktiv sein.</blockquote>

            <!-- Leistungskennzahlen -->
            <h2>Leistungskennzahlen</h2>
            <ul>
                <li><strong>CPU-Auslastung</strong></li>
                <li><strong>Durchsatz (Throughput)</strong></li>
                <li><strong>Turnaround Time</strong></li>
                <li><strong>Wartezeit (Waiting Time)</strong></li>
                <li><strong>Antwortzeit (Response Time)</strong></li>
            </ul>

            <!-- Scheduling-Algorithmen -->
            <h2>Grundlegende Scheduling-Algorithmen</h2>

            <h3>First-Come, First-Served (FCFS)</h3>
            <ul>
                <li>Nicht-präemptiv.</li>
                <li>Einfach, aber Konvoi-Effekt erhöht Wartezeiten.</li>
            </ul>
            <div class="gantt">Beispiel: P1(24), P2(3), P3(3)<br>|---P1---|--P2--|--P3--|<br>Ø Wartezeit = 17</div>

            <h3>Shortest-Job-First (SJF) / Shortest-Remaining-Time (SRT)</h3>
            <ul>
                <li>Wählt kürzeste Jobs (Restlaufzeit).</li>
                <li>SRT präemptiv, minimaler mittlerer Wartezeit, Gefahr des Verhungerns.</li>
            </ul>
            <div class="gantt">Ablauf: |--P2--|--P3--|------P1------|<br>Ø Wartezeit = 3</div>

            <h3>Prioritätsbasiertes Scheduling</h3>
            <ul>
                <li>Prozesse haben Prioritäten (statisch/dynamisch).</li>
                <li>Präemptiv, löst Starvation durch Aging.</li>
                <li>Lösung für Prioritätsinversion: Priority Inheritance.</li>
            </ul>

            <h3>Round Robin (RR)</h3>
            <ul>
                <li>Zeitscheiben-Quantum, präemptiv.</li>
                <li>Fair, gute Antwortzeiten, Overhead bei zu kleinem Quantum.</li>
            </ul>
            <div class="gantt">Beispiel (Quantum=4): |P1(4)|P2(3)|P3(3)|P1(4)|P1(4)|</div>

            <h3>Multilevel Queue Scheduling</h3>
            <p>Mehrere Ready Queues für verschiedene Prozessklassen (Batch, Interactive).</p>
            <div class="image-placeholder">[Diagramm: Ready Queues Hierarchie]</div>

            <h3>Multilevel Feedback Queue (MLFQ)</h3>
            <p>Erlaubt Wechsel zwischen Queues basierend auf Prozessverhalten, verhindert Verhungern.</p>

            <h3>Echtzeit-Scheduling</h3>
            <h4>Earliest Deadline First (EDF)</h4>
            <p>Dynamisch Prioritäten nach nächster Deadline, optimal auf einem Prozessor.</p>
            <blockquote>Unter Überlast dominiert Dominoeffekt.</blockquote>
            <h4>Rate Monotonic Scheduling (RMS)</h4>
            <p>Statische Prioritäten nach Periode, optimal bei Auslastung ≤ n(2^{1/n}-1).</p>

            <h2>Scheduling in Mehrprozessorumgebungen</h2>
            <ul>
                <li><strong>Prozessoraffinität:</strong> Lokale Caches schonen.</li>
                <li><strong>Gang Scheduling:</strong> Threads-Gruppen synchron ausführen.</li>
            </ul>

            <h2>Scheduling in der Praxis</h2>
            <h3>Windows</h3>
            <ul>
                <li>32 Prioritätsstufen (1–15 User, 16–31 Echtzeit).</li>
                <li>Dynamische Prioritätsanpassung für interaktive Threads und CPU-lastige Threads.</li>
                <li>Priority Boost für lange wartende Threads.</li>
            </ul>
            <h3>Linux</h3>
            <ul>
                <li>Echtzeit-Klassen (FIFO, RR) vor allen anderen.</li>
                <li>Nicht-Echtzeit-Klasse: komplexer, fairer Algorithmus, bevorzugt I/O-lastige Threads.</li>
            </ul>

            <h2>Zusammenfassung</h2>
            <ul>
                <li>Viele Algorithmen mit spezifischen Vor- und Nachteilen.</li>
                <li>Wahl abhängig von Systemtyp: Batch, interaktiv, Echtzeit.</li>
                <li>Trade-offs zwischen Durchsatz, Antwortzeiten, Fairness und Overhead.</li>
            </ul>

        </article>
    </main>

    <footer>
        <div class="container">
            <p>Erstellt zur Unterstützung der Prüfungsvorbereitung. Viel Erfolg bei der Klausur!</p>
        </div>
    </footer>

    <script src="js/main.js"></script>
</body>
</html>
